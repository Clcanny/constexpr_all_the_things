<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>constexpr ALL the things!</title>
<meta name="author" content="(Ben Deane & Jason Turner)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><img src="title.png"><h3>Ben Deane / <a href="mailto:bdeane@blizzard.com">bdeane@blizzard.com</a> / <a href="http://twitter.com/ben_deane">@ben_deane</a></h3><h3>Jason Turner / <a href="mailto:jason@emptycrate.com">jason@emptycrate.com</a> / <a href="http://twitter.com/lefticus">@lefticus</a></h3><h4>C++Now / Tuesday 16th May 2017</h4>
</section>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org6d2ef76">
<h2 id="org6d2ef76">Don't Bury The Lead</h2>
<p>
We want to do this:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsv
  = R<span style="color: #b22222;">"({</span>
<span style="color: #b22222;">        "</span>feature-x-enabled<span style="color: #b22222;">"</span><span style="color: #b22222;">: true,</span>
<span style="color: #b22222;">        "</span>value-of-y<span style="color: #b22222;">": 1729,</span>
<span style="color: #b22222;">        "</span>z-options<span style="color: #b22222;">": {"</span>a<span style="color: #b22222;">": null,</span>
<span style="color: #b22222;">                      "</span>b<span style="color: #b22222;">": "</span><span style="color: #008b8b;">220</span> <span style="color: #a020f0;">and</span> <span style="color: #008b8b;">284</span><span style="color: #b22222;">",</span>
<span style="color: #b22222;">                      "</span>c<span style="color: #b22222;">": [6, 28, 496]}</span>
<span style="color: #b22222;">       })"</span>_json;
<span style="color: #a020f0;">if</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #707183;">(</span>jsv<span style="color: #7388d6;">[</span><span style="color: #b22222;">"feature-x-enabled"</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">code for feature x</span>
<span style="color: #707183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #707183;">{</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">code when feature x turned off</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
When I first heard about <code>constexpr</code> I immediately thought of the potential for
this: generating compile-time data structures with UDLs. And JSON is an obvious
choice for a proof-of-concept.
</p>

<p>
Why JSON?
</p>
<ul>
<li>not too difficult (small grammar, well known)</li>
<li>sufficiently interesting (deal with recursive structure at compile time
without memory management)</li>
<li>ubiquitous, useful?</li>

</ul>

</aside>

</section>
</section>
<section>
<section id="slide-orgad3360d">
<h2 id="orgad3360d">The Promise of <code>constexpr</code></h2>
<ul>
<li>Runtime efficiency</li>
<li>Clearer code, fewer magic numbers</li>
<li>Less cross-platform pain</li>

</ul>

<aside class="notes">
<p>
Jason talks about this.
</p>

<p>
Doing work at compile-time instead of runtime. Obvious gain.
</p>

<p>
Simplifying code through compile-time computation. No need for manual math,
preprocessor computation "to be sure", magic numbers.
</p>

<p>
Reducing steps in the toolchain. Don't maintain generation scripts: put it in
the C++.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgde5fe13">
<h2 id="orgde5fe13"><code>constexpr</code> History 101</h2>
<p>
A Short, Incomplete (and Mostly Wrong?) History of <code>constexpr</code>
</p>

<aside class="notes">
<p>
Ben to drive this section.
</p>

</aside>

</section>
<section id="slide-org1ff890f">
<h3 id="org1ff890f"><code>constexpr</code>: The First Age</h3>
<ul>
<li class="fragment appear">One (<code>return</code>) expression per function was allowed</li>
<li class="fragment appear"><code>constexpr</code> math functions explored</li>
<li class="fragment appear"><code>throw</code> link error trick discovered</li>
<li class="fragment appear">Recursive <code>constexpr</code> FNV1 string hash discovered</li>

</ul>

<aside class="notes">
<p>
C++11 constexpr was "extreme recursion" but many things were doable nonetheless.
</p>

<p>
Scott Schurr's talks at CppNow/CppCon hinted at things to come and expounded on
the throw trick for forcing compile-time evaluation.
</p>

</aside>

</section>
<section id="slide-org315a689">
<h3 id="org315a689"><code>constexpr</code>: End of the First Age</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">1. Fall of Gondolin</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">2. Balrogs destroyed</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">3. Morgoth defeated and cast into the Timeless Void</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">4. constexpr string hashing discovered</span>

<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">uint64_t</span> <span style="color: #0000ff;">fnv1</span><span style="color: #707183;">(</span><span style="color: #228b22;">uint64_t</span> <span style="color: #a0522d;">h</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>*s == <span style="color: #008b8b;">0</span><span style="color: #7388d6;">)</span> ? h :
    fnv1<span style="color: #7388d6;">(</span><span style="color: #909183;">(</span><span style="color: #228b22;">h</span> * <span style="color: #008b8b;">1</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">099</span><span style="color: #008b8b;">511</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">628</span><span style="color: #008b8b;">211</span><span style="color: #008b8b;">ull</span><span style="color: #909183;">)</span> ^ <span style="color: #a020f0;">static_cast</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">uint64_t</span><span style="color: #909183;">&gt;(</span>*s<span style="color: #909183;">)</span>, s+<span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
At this point most people are probably familiar with this or something like it.
</p>

</aside>

</section>
<section id="slide-org1617523">
<h3 id="org1617523"><code>constexpr</code>: The Second Age</h3>
<ul>
<li class="fragment appear">Generalized <code>constexpr</code> supported by Visual C++</li>
<li class="fragment appear">Compile-time computation/optimization popularized by <a href="https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1"><i>C++ Weekly</i></a> et al.</li>
<li class="fragment appear">Generalized <code>constexpr</code> string hashing (e.g. Murmur3) discovered</li>
<li class="fragment appear"><code>constexpr</code> libraries start to appear</li>

</ul>

<aside class="notes">
<p>
For some reason, the major application of <code>constexpr</code> reported in the mainstream
seems to be string hashing.
</p>

</aside>

</section>
<section id="slide-org506f999">
<h3 id="org506f999"><code>constexpr</code>: End of the Second Age</h3>

<div class="figure">
<p><img src="./cpp14_murmur.png" alt="cpp14_murmur.png" />
</p>
</div>

<p>
(Also: Last Alliance of Elves &amp; Men, Isildur takes up the hilt of Narsil<br />
and cuts the One Ring from Sauron's hand.)
</p>

</section>
<section id="slide-org86f3f26">
<h3 id="org86f3f26"><code>constexpr</code>: The Third Age?</h3>
<ul>
<li class="fragment appear"><code>constexpr</code> lambdas</li>
<li class="fragment appear"><code>if constexpr</code></li>
<li class="fragment appear"><code>constexpr</code> STL proliferation?</li>
<li class="fragment appear">(coming soon, no doubt) <code>constexpr</code> cryptographic hashes</li>

</ul>

<aside class="notes">
<p>
<code>constexpr</code> lambdas are a really powerful thing (as we shall see).
</p>

<p>
<code>if constexpr</code> replaces many <code>std::enable_if</code> uses, more.
</p>

<p>
A selection of interesting <code>constexpr</code> things in the STL: <code>string_view</code>,
<code>array</code>, almost all of <code>chrono</code>.
</p>

<p>
New STL features are born with <code>constexpr</code> (somewhat) in mind: <code>optional</code>,
<code>variant</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org3ffb437">
<h2 id="org3ffb437">A problem with <code>constexpr</code></h2>

<div class="figure">
<p><img src="./constexpr_problem.png" alt="constexpr_problem.png" />
</p>
</div>

<p>
The inability to use different runtime and compile time algorithms.
</p>

</section>
<section id="slide-orgeddcbd5">
<h3 id="orgeddcbd5"><code>constexpr</code> SFINAE?</h3>
<p>
A partial solution, perhaps.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> str_view = <span style="color: #b22222;">"Computers are useless."</span>sv;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> cx_hash = fnv1<span style="color: #707183;">(</span>str_view<span style="color: #707183;">)</span>;

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">str</span> = <span style="color: #b22222;">"They can only give you answers."</span>s;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rt_hash</span> = fnv1<span style="color: #707183;">(</span>str<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
We would <i>like</i> the second call to <code>fnv1</code> to use an efficient runtime algorithm.
</p>

</section>
<section id="slide-orgf98e44b">
<h3 id="orgf98e44b"><code>constexpr</code> SFINAE?</h3>
<p>
You <i>can</i> do something like this&#x2026;
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">constexpr_construct_t</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">integral_constant</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">bool</span>, <span style="color: #7388d6;">(</span>T<span style="color: #909183;">{}</span>, <span style="color: #008b8b;">true</span><span style="color: #7388d6;">)</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
And then feed it to the detection idiom.
</p>

<aside class="notes">
<p>
If <code>T</code> is <code>constexpr</code> constructible, it will be admissible as a compile-time
argument to the comma operator, and therefore the result will be a well-formed
template argument.
</p>

<p>
The use of the comma is similar to <code>void_t</code> here: we're turning any value into a
boolean.
</p>

<p>
Whatever expression we put in the arguement to comma will have to be evaluated
at compile time in order for the type to be well-formed. And we can then use
this type with the new detection idiom.
</p>

</aside>

</section>
<section id="slide-orga8a6580">
<h3 id="orga8a6580"><code>constexpr</code> SFINAE?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">StringType</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">fnv1</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">StringType</span>&amp; <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #a020f0;">constexpr</span><span style="color: #7388d6;">(</span>is_detected_v&lt;constexpr_construct_t, StringType&gt;<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">cx</span>::fnv1<span style="color: #909183;">(</span>s<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">runtime</span>::fnv1<span style="color: #909183;">(</span>s<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
Caveats: many.
</p>
<ul>
<li class="fragment appear">"<code>constexpr</code> constructible" doesn't mean "<code>constexpr</code> hashable"</li>
<li class="fragment appear">"<code>constexpr</code> capable" doesn't mean "in a <code>constexpr</code> context"</li>
<li class="fragment appear">verbosity, compile time?</li>

</ul>

<aside class="notes">
<p>
If you're going to go with this kind of thing, you're practically going down the
route of completely different types for use at compile time and runtime.
</p>

</aside>

</section>
<section id="slide-orgba057cf">
<h3 id="orgba057cf"><code>constexpr</code> SFINAE?</h3>
<p>
Another possible (better) solution.
</p>


<div class="figure">
<p><img src="./constexpr_operator.png" alt="constexpr_operator.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-org267b989">
<h2 id="org267b989">Building <code>constexpr</code> JSON Values</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsv
  = R<span style="color: #b22222;">"({</span>
<span style="color: #b22222;">        "</span>feature-x-enabled<span style="color: #b22222;">": true,</span>
<span style="color: #b22222;">        "</span>value-of-y<span style="color: #b22222;">": 1729,</span>
<span style="color: #b22222;">        "</span>z-options<span style="color: #b22222;">": {"</span>a<span style="color: #b22222;">": null,</span>
<span style="color: #b22222;">                      "</span>b<span style="color: #b22222;">": "</span><span style="color: #008b8b;">220</span> <span style="color: #a020f0;">and</span> <span style="color: #008b8b;">284</span><span style="color: #b22222;">",</span>
<span style="color: #b22222;">                      "</span>c<span style="color: #b22222;">": [6, 28, 496]}</span>
<span style="color: #b22222;">       })"</span>_json;
</pre>
</div>

<p>
Two problems to solve:
</p>

<ol>
<li>How to represent JSON values</li>
<li>How to parse JSON values</li>

</ol>

</section>
</section>
<section>
<section id="slide-org9a6d011">
<h2 id="org9a6d011">Representing JSON Values</h2>
<p>
A JSON Value is a discriminated union of:<br />
<br />
</p>
<ul>
<li class="fragment appear">null</li>
<li class="fragment appear">boolean</li>
<li class="fragment appear">number</li>
<li class="fragment appear">string</li>
<li class="fragment appear">array of values</li>
<li class="fragment appear">object (map of string -&gt; value)</li>

</ul>

<p class="fragment (appear)">
<br />
Clearly this is going to need some sort of recursion. And we are going to need
<code>constexpr</code> ways to deal with a string, a vector and a map.
</p>

<aside class="notes">
<p>
Jason to drive this section.
</p>

</aside>

</section>
<section id="slide-orgda7d499">
<h3 id="orgda7d499"><code>constexpr</code> strings</h3>
<p>
<br />
First, <code>std::string_view</code> is great, and <i>mostly</i> <code>constexpr</code><br />
(depending on how up-to-date your library implementation is).<br />
<br />
<br />
Of course, <code>std::string_view</code> only really handles literal values:<br />
it doesn't deal with building strings, and is not intended for <i>storing</i> strings.
</p>

<aside class="notes">
<p>
<code>string_view</code> comparison is not yet <code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-org69f500c">
<h3 id="org69f500c"><code>constexpr</code> strings</h3>
<p>
<br />
We need a way to pass, store, and in general, work with<br />
character string literals.<br />
<br />
<br />
While <code>std::string_view</code> would technically work for this<br />
it kind of mixes metaphors, since it is not intended for storing<br />
and comparison - just viewing.<br />
<br />
<br />
For this, we built up the <code>static_string</code> class.
</p>

</section>
<section id="slide-orgae875b0">
<h3 id="orgae875b0"><code>constexpr</code> strings</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">static_string</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span><span style="color: #7388d6;">&gt;</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">static_string</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #909183;">(</span>&amp;<span style="color: #a0522d;">str</span><span style="color: #909183;">)[</span>N<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>
    : m_size<span style="color: #7388d6;">(</span>N-<span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">m_data</span><span style="color: #7388d6;">(</span>&amp;str<span style="color: #909183;">[</span><span style="color: #008b8b;">0</span><span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">constructor for substrings of string literals</span>
  <span style="color: #a020f0;">constexpr</span> static_string<span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">str</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span>
    : m_size<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>, <span style="color: #228b22;">m_data</span><span style="color: #7388d6;">(</span><span style="color: #a0522d;">str</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>

  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">static_string</span><span style="color: #7388d6;">()</span> = <span style="color: #a020f0;">default</span>;

  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">size</span><span style="color: #7388d6;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> m_size; <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #0000ff;">c_str</span><span style="color: #7388d6;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> m_data; <span style="color: #7388d6;">}</span>

  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">m_data</span> = <span style="color: #008b8b;">nullptr</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgbdbe999">
<h3 id="orgbdbe999"><code>constexpr</code> vectors</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Value</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span> = <span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">vector</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">storage_t</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Value</span>, Size<span style="color: #7388d6;">&gt;</span>;
  <span style="color: #228b22;">storage_t</span> <span style="color: #a0522d;">m_data</span><span style="color: #7388d6;">{}</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
  ...

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">iterators, push_back, operator[] etc</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">are pretty easy to write</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Obviously we need to know the max size at compile time.
</p>

</aside>

</section>
<section id="slide-org822dd4d">
<h3 id="org822dd4d"><code>constexpr</code> vectors</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">iterator</span> = <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">storage_t</span>::<span style="color: #228b22;">iterator</span>;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">const_iterator</span> = <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">storage_t</span>::<span style="color: #228b22;">const_iterator</span>;

<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">begin</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> m_data.begin<span style="color: #7388d6;">()</span>; <span style="color: #707183;">}</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">end</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> m_data.begin<span style="color: #7388d6;">()</span> + m_size; <span style="color: #707183;">}</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">and similarly for other iterator functions...</span>

<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">Value</span> <span style="color: #a0522d;">t_v</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_size &gt;= Size<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">throw</span> <span style="color: #008b8b;">std</span>::range_error<span style="color: #909183;">(</span><span style="color: #b22222;">"Index past end of vector"</span><span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
    m_data<span style="color: #909183;">[</span>m_size++<span style="color: #909183;">]</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #909183;">(</span>t_v<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
We were not able to use <code>std::next()</code> here, seems to be a bug in the implementation&#x2026;
</p>

<aside class="notes">
<p>
Note that the <code>throw</code> here is a nicety: if we were to read/write past the end of
a <code>constexpr</code> array the compiler would give an error anyway. Assuming we are working
in a <code>constexpr</code> context. This throw protects us if this class is used just for a handy
statically sized vector.
</p>

</aside>

</section>
<section id="slide-orgd89bfa2">
<h3 id="orgd89bfa2">Why not <code>std::next</code>?</h3>
<p>
In GCC's implementation: internal <code>__iterator_category</code> is not <code>constexpr</code> constructible.
</p>

<iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Carray%3E%0A%23include+%3Citerator%3E%0A%0Ausing+namespace+std%3B%0A%0Aconstexpr+array%3Cint,+5%3E+foo+%3D+%7B1,2,3,4,5%7D%3B%0A%0Aconstexpr+auto+third_of_foo()%0A%7B%0A++return+next(foo.cbegin(),+3)%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+i+%3D+*third_of_foo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.5479341055999998,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:21.627408993576015,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:78.37259100642399,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

</section>
<section id="slide-org0b6ff74">
<h3 id="org0b6ff74"><code>constexpr</code> vectors</h3>
<p>
This allows for natural use of the <code>vector</code> type
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">vec</span>;
vec.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">15</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org93158c7">
<h3 id="org93158c7"><code>constexpr</code> vectors</h3>
<p>
Or put into a <code>constexpr</code> context
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">get_vector</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">vector</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">vec</span>;
  vec.push_back<span style="color: #7388d6;">(</span><span style="color: #008b8b;">15</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> vec;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> a_vector = get_vector<span style="color: #7388d6;">()</span>;
  static_assert<span style="color: #7388d6;">(</span>a_vector.size<span style="color: #909183;">()</span> == <span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org57ec2e1">
<h3 id="org57ec2e1">mutable <code>constexpr</code> strings</h3>
<p>
And now we can build a mutable <code>constexpr</code> string by inheriting from our <code>vector</code>
</p>

</section>
<section id="slide-org37935c3">
<h3 id="org37935c3">mutable <code>constexpr</code> strings</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">CharType</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">basic_string</span> : <span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">CharType</span>, Size<span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">basic_string</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">static_string</span> &amp;<span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> 
    : vector<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">CharType</span>, Size<span style="color: #7388d6;">&gt;(</span>s.begin<span style="color: #909183;">()</span>, s.end<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>
  <span style="color: #a020f0;">constexpr</span> basic_string<span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> &amp;<span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span>
    : vector<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">CharType</span>, Size<span style="color: #7388d6;">&gt;(</span>s.cbegin<span style="color: #909183;">()</span>, s.cend<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">...</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

<p>
This relies on:
</p>
<ul>
<li><code>constexpr</code> data members must be initialized, so our base vector is all <code>0</code></li>
<li>We have not provided any methods for shrinking our data structures, but that is possible</li>

</ul>

</section>
<section id="slide-orgfa791a0">
<h3 id="orgfa791a0"><code>constexpr</code> maps</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Key</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Value</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span> = <span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">map</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">storage_t</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">pair</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">Key</span>, <span style="color: #228b22;">Value</span><span style="color: #909183;">&gt;</span>, Size<span style="color: #7388d6;">&gt;</span>;
  <span style="color: #228b22;">storage_t</span> <span style="color: #a0522d;">m_data</span><span style="color: #7388d6;">{}</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
  ...

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">iterators are the same as for arrays</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">operator[] needs a constexpr find</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">data grows in the same way that vector does</span>
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orga69a727">
<h3 id="orga69a727"><code>constexpr</code> maps</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">get_colors</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">cx</span>::static_string, <span style="color: #008b8b;">std</span>::uint32_t<span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">colors</span>;
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #ffffff; background-color: #ff0000;">red</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">0x</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">FF</span><span style="color: #008b8b;">0000</span>;
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #000000; background-color: #00ff00;">green</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">0x</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">00</span><span style="color: #008b8b;">FF00</span>;
  <span style="color: #a020f0;">return</span> colors;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> colors = get_colors<span style="color: #7388d6;">()</span>;
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #ffffff; background-color: #ff0000;">red</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span>; <span style="color: #bebebe;">// </span><span style="color: #bebebe;">returns 0x</span><span style="color: #bebebe; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">FF</span><span style="color: #bebebe;">0000</span>
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #ffffff; background-color: #0000ff;">blue</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span>; <span style="color: #bebebe;">// </span><span style="color: #bebebe;">compile-time error</span>
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org2bf7467">
<h3 id="org2bf7467">Why not <code>std::pair</code>?</h3>
<p>
Standard library definition does not have<br />
<code>constexpr operator=</code> for <code>std::pair</code><br />
<br />
This is the only aspect of <code>std::pair</code> that is not <code>constexpr</code>
</p>

<iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Cutility%3E%0A%0Ausing+namespace+std%3B%0A%0Astruct+P+%0A%7B%0A++std::pair%3Cconst+char*,+int%3E+pr%3B%0A%7D%3B%0A%0Aconstexpr+auto+pair_test()%0A%7B%0A++P+p%3B%0A++p.pr+%3D+make_pair(%22taxicab%22,+1729)%3B%0A++return+p%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+p+%3D+pair_test()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.2899450879999999,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:19.48608137044968,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:80.51391862955032,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

</section>
<section id="slide-org6f556a0">
<h3 id="org6f556a0"><code>constexpr find_if</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryPredicate</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">InputIt</span> <span style="color: #0000ff;">find_if</span><span style="color: #707183;">(</span><span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">last</span>, <span style="color: #228b22;">UnaryPredicate</span> <span style="color: #a0522d;">p</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span>; first != last; ++first<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>p<span style="color: #709870;">(</span>*first<span style="color: #709870;">)</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">return</span> first;
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">return</span> last;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
There's no technical reason for many algorithms not to be <code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-orgbc94f1d">
<h3 id="orgbc94f1d">Let's make them all <code>constexpr</code> already</h3>

<div class="figure">
<p><img src="./bryce_tweet.png" alt="bryce_tweet.png" />
</p>
</div>

</section>
<section id="slide-org872d1f3">
<h3 id="org872d1f3">Other algorithms we made <code>constexpr</code></h3>
<ul>
<li><code>mismatch</code></li>
<li><code>equal</code></li>
<li><code>copy</code></li>

</ul>

<p>
In the course of implementing this talk, we found uses for several <code>constexpr</code>
algorithms.
</p>

</section>
<section id="slide-orgd88e11a">
<h3 id="orgd88e11a">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span>=<span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_vector_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">6</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_map_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">6</span><span style="color: #7388d6;">}</span>;

  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">boolean</span><span style="color: #909183;">{</span><span style="color: #008b8b;">false</span><span style="color: #909183;">}</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span><span style="color: #909183;">{</span><span style="color: #008b8b;">0</span><span style="color: #909183;">}</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span> <span style="color: #a0522d;">string</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span>, <span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">enum</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Type</span> <span style="color: #7388d6;">{</span> <span style="color: #a0522d;">Null</span>, <span style="color: #a0522d;">Boolean</span>, <span style="color: #a0522d;">Number</span>, <span style="color: #a0522d;">String</span>, <span style="color: #a0522d;">Array</span>, <span style="color: #a0522d;">Object</span> <span style="color: #7388d6;">}</span>;

  <span style="color: #228b22;">Type</span> <span style="color: #a0522d;">type</span> = <span style="color: #008b8b;">Type</span>::Null;
  <span style="color: #228b22;">Data</span> <span style="color: #a0522d;">data</span>;
  ...
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;&gt;</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">0</span><span style="color: #707183;">&gt;</span> <span style="color: #707183;">{}</span>;
</pre>
</div>

<aside class="notes">
<p>
This makes for a lot of template instantiations, and has some obvious limitations.
</p>

<p>
The max sizes for arrays and objects are determined empirically.
</p>

<p>
We use <code>struct</code> here initially, but <code>union</code> later.
</p>

</aside>

</section>
<section id="slide-org6569524">
<h3 id="org6569524">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">assert_type</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Type</span> <span style="color: #a0522d;">t</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">const</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>type != t<span style="color: #909183;">)</span> <span style="color: #a020f0;">throw</span> <span style="color: #008b8b;">std</span>::runtime_error<span style="color: #909183;">(</span><span style="color: #b22222;">"Incorrect type"</span><span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">For Array, and similarly for the other types</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">decltype</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span><span style="color: #7388d6;">)</span> <span style="color: #0000ff;">to_Array</span><span style="color: #7388d6;">()</span> <span style="color: #a020f0;">const</span>
  <span style="color: #7388d6;">{</span>
    assert_type<span style="color: #909183;">(</span><span style="color: #008b8b;">Type</span>::Array<span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #909183;">(</span>data.array<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">decltype</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span><span style="color: #7388d6;">)</span> <span style="color: #0000ff;">to_Array</span><span style="color: #7388d6;">()</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>type != <span style="color: #008b8b;">Type</span>::Array<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      type = <span style="color: #008b8b;">Type</span>::Array;
      data.array = <span style="color: #709870;">{}</span>;
    <span style="color: #909183;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #909183;">(</span>data.array<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgf88414c">
<h3 id="orgf88414c">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">JSON_Value</span> <span style="color: #a0522d;">j</span><span style="color: #707183;">{}</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">]</span>.to_Number<span style="color: #707183;">()</span> = <span style="color: #008b8b;">15</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"b"</span><span style="color: #707183;">]</span>.to_String<span style="color: #707183;">()</span> = <span style="color: #b22222;">"Hello World"</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"d"</span><span style="color: #707183;">]</span>.to_Array<span style="color: #707183;">()</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"b"</span><span style="color: #707183;">]</span>.to_Array<span style="color: #707183;">()</span>.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">10.0</span><span style="color: #707183;">)</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">]</span> = <span style="color: #008b8b;">cx</span>::static_string<span style="color: #707183;">(</span><span style="color: #b22222;">"Hello World"</span><span style="color: #707183;">)</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"d"</span><span style="color: #707183;">]</span>.to_Array<span style="color: #707183;">()</span>.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">5.2</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
But this kind of thing works. Note that we are using C++17 class template type
deduction here so we don't need to say <code>cx::JSON_Value&lt;&gt; j{};</code>
</p>

</aside>

</section>
<section id="slide-org9044503">
<h3 id="org9044503">Why not <code>std::variant</code> ?</h3>
<p>
Similarly to <code>std::pair</code>, <code>std::variant</code> is missing some key <code>constexpr</code> support.
</p>

<ul>
<li class="fragment appear"><code>std::variant(const std::variant &amp;)</code></li>
<li class="fragment appear"><code>std::variant(std::variant &amp;&amp;)</code></li>
<li class="fragment appear"><code>std::variant &amp;operator=(const std::variant &amp;)</code></li>
<li class="fragment appear"><code>std::variant &amp;operator=(std::variant &amp;&amp;)</code></li>

</ul>

</section>
<section id="slide-org0db449a">
<h3 id="org0db449a">Requirements for compile-time types</h3>
<p>
Huge list! Are you ready?! 
</p>

<ul>
<li class="fragment appear"><code>constexpr</code> constructor</li>
<li class="fragment appear"><code>std::is_trivially_destructible</code></li>

</ul>

<p class="fragment (appear)">
Nothing else is required if it does not get invoked.
</p>

</section>
<section id="slide-orgdaecd92">
<h3 id="orgdaecd92">STL shortcomings</h3>
<ul>
<li><code>array</code></li>
<li><code>string</code></li>
<li><code>string_view</code></li>
<li><code>pair</code></li>
<li><code>optional</code></li>
<li><code>variant</code></li>
<li><code>swap</code></li>

</ul>

<aside class="notes">
<p>
Many of these parts of the STL have <code>constexpr</code> desires and partially
<code>constexpr</code> friendly implementations.
</p>

<p>
In our experience, none of them quite achieves everything that is possibly
<code>constexpr</code>. In many cases this could just be an oversight in the implementation
or the standard and not because of some deep reason.
</p>

</aside>

</section>
<section id="slide-org51fdf33">
<h3 id="org51fdf33">Limitations of our containers</h3>
<ul>
<li>Fixed maximum size</li>
<li>(Currently) cannot shrink</li>
<li>Requires types that are default constructible</li>

</ul>

</section>
<section id="slide-org8b177dd">
<h3 id="org8b177dd">How to improve our containers</h3>
<ul>
<li>We could wrap objects in <code>std::optional</code> to allow for objects that are not default constructible</li>
<li>It should be possible to templatize on <code>constexpr</code> enabled allocator, making these containers optionally <code>constexpr</code></li>

</ul>

</section>
<section id="slide-org829d0e7">
<h3 id="org829d0e7"><code>constexpr</code> allocator?</h3>
<p>
From cppreference.com
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">SimpleAllocator</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">T</span> <span style="color: #228b22;">value_type</span>;
  <span style="color: #0000ff;">SimpleAllocator</span><span style="color: #7388d6;">(</span><span style="color: #bebebe;">/*</span><span style="color: #bebebe;">ctor args*/</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span> <span style="color: #0000ff;">SimpleAllocator</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #909183;">&gt;</span>&amp; <span style="color: #a0522d;">other</span><span style="color: #7388d6;">)</span>;
  <span style="color: #228b22;">T</span>* <span style="color: #0000ff;">allocate</span><span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">deallocate</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">T</span>* <span style="color: #a0522d;">p</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>;
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>&amp;, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span>&amp;<span style="color: #707183;">)</span>;
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>&amp;, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span>&amp;<span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org93c0461">
<h3 id="org93c0461"><code>constexpr</code> allocator?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">ConstexprAllocator</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">T</span> <span style="color: #228b22;">value_type</span>;
  <span style="color: #228b22;">consstexpr</span> <span style="color: #0000ff;">ConstexprAllocator</span><span style="color: #7388d6;">(</span><span style="color: #bebebe;">/*</span><span style="color: #bebebe;">ctor args*/</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span> 
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">ConstexprAllocator</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">ConstexprAllocator</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #909183;">&gt;</span>&amp; <span style="color: #a0522d;">other</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">T</span>* <span style="color: #0000ff;">allocate</span><span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">constexpr</span>  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">deallocate</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">T</span>* <span style="color: #a0522d;">p</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">bool</span>, <span style="color: #228b22;">value_type</span><span style="color: #909183;">&gt;</span>, Size<span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">data</span>; <span style="color: #bebebe;">// </span><span style="color: #bebebe;">bool for free flag</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

<p>
Implementation left as an exercise to the reader.
</p>

</section>
</section>
<section>
<section id="slide-orgf2cba34">
<h2 id="orgf2cba34">Parsing JSON Value Literals</h2>
<p>
Because we need some way to actually turn a string literal into our JSON
representation.
</p>

<aside class="notes">
<p>
Ben drives this section.
</p>

</aside>

</section>
<section id="slide-org766be2b">
<h3 id="org766be2b">What is a Parser?</h3>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">::</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>a, <span style="color: #228b22;">String</span><span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div>
<p>
"A parser for things is a function from strings to lists of pairs of things and strings."
</p>

<p>
&#x2013; <a href="http://www.willamette.edu/~fruehr/haskell/seuss.html">Dr Seuss on parsers</a><br />
<br />
<br />
Or in our case something like:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parser</span> = <span style="color: #a020f0;">auto</span> <span style="color: #707183;">(</span>*<span style="color: #707183;">)(</span>string<span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">list</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span>, <span style="color: #228b22;">string</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<aside class="notes">
<p>
This serendipitous phrase is due to Fritz Ruehr, a functional programming
lecturer at Willamette University.
</p>

</aside>

</section>
<section id="slide-orgd55ac15">
<h3 id="orgd55ac15">Parsers</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parser</span> = <span style="color: #a020f0;">auto</span> <span style="color: #707183;">(</span>*<span style="color: #707183;">)(</span>string<span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">list</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span>, <span style="color: #228b22;">string</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
Of course, we don't really mean quite this&#x2026;
</p>

<ul>
<li class="fragment appear"><code>string</code> -&gt; <code>string_view</code> (compile-time stringlike thing)</li>
<li class="fragment appear"><code>list</code> -&gt; <code>optional</code> (simpler)</li>
<li class="fragment appear">"function" -&gt; "something invocable"</li>

</ul>

<aside class="notes">
<p>
Strings are any stringlike thing - <code>string_view</code> will do nicely since we're just
reading this from a literal. The input is obvious, the output is the leftover
part of the string after parsing a T.
</p>

<p>
List represents optionality - a given string might have several ways it can be
parsed. For simplicity we can just assume one way or error, i.e. optional.
</p>

<p>
Of course we'll use the <code>constexpr</code> friendly <code>pair</code>.
</p>

<p>
And when we say "function" we mean the usual invocable things. Including <code>constexpr</code>
lambdas!
</p>

</aside>

</section>
<section id="slide-orga260578">
<h3 id="orga260578">A Simple Parser</h3>
<p>
Let's have a couple of aliases that will make life simpler.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">parse_input_t</span> = <span style="color: #008b8b;">std</span>::string_view;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parse_result_t</span> = <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span>, <span style="color: #228b22;">parse_input_t</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
And let's make a parser that matches a single <code>char</code> that we give it.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> match_char<span style="color: #707183;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>s.empty<span style="color: #909183;">()</span> || s<span style="color: #909183;">[</span><span style="color: #008b8b;">0</span><span style="color: #909183;">]</span> != c<span style="color: #7388d6;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
  <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;(</span>
    <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #909183;">(</span>c, parse_input_t<span style="color: #709870;">(</span>s.data<span style="color: #907373;">()</span>+<span style="color: #008b8b;">1</span>, s.size<span style="color: #907373;">()</span>-<span style="color: #008b8b;">1</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is what a parser does: either matches or not (hence the optional) and if it
matches, returns the value matched and the rest of the string for use in future
parsers.
</p>

</aside>

</section>
<section id="slide-org8e68d33">
<h3 id="org8e68d33">A Simple Parser</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">Ceci n'est pas une parser.</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> match_char<span style="color: #707183;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
<code>match_char</code> isn't actually a parser, because it has the wrong signature.<br />
<br />
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">This is the signature of a parser.</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parser</span> = <span style="color: #a020f0;">auto</span> <span style="color: #707183;">(</span>*<span style="color: #707183;">)(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
But now that we have <code>constexpr</code> lambdas, we can write a function that returns a
parser.
</p>

</section>
<section id="slide-org620dab1">
<h3 id="org620dab1">A Simple Parser</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_char_parser</span><span style="color: #707183;">(</span><span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>s.empty<span style="color: #709870;">()</span> || s<span style="color: #709870;">[</span><span style="color: #008b8b;">0</span><span style="color: #709870;">]</span> != c<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
    <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #909183;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #909183;">&gt;(</span>
        <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #709870;">(</span>c, parse_input_t<span style="color: #907373;">(</span>s.data<span style="color: #6276ba;">()</span>+<span style="color: #008b8b;">1</span>, s.size<span style="color: #6276ba;">()</span>-<span style="color: #008b8b;">1</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
The lambda returned from <code>make_char_parser</code> is a parser that will match the
given <code>char</code>.
</p>

</section>
<section id="slide-org450fbde">
<h3 id="org450fbde">More useful primitive parsers</h3>
<p>
So far we can match one <code>char</code>. Because fundamentally parsing works on
"strings", there are a couple of other parsers that will be useful.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">parse one of a set of chars</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">one_of</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">chars</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>s.empty<span style="color: #709870;">()</span><span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">basic_string_view::find is supposed to be constexpr, but no...</span>
    <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">j</span> = <span style="color: #008b8b;">cx</span>::find<span style="color: #909183;">(</span>chars.cbegin<span style="color: #709870;">()</span>, chars.cend<span style="color: #709870;">()</span>, s<span style="color: #709870;">[</span><span style="color: #008b8b;">0</span><span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>j != chars.cend<span style="color: #709870;">()</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #709870;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #709870;">&gt;(</span>
          <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #907373;">(</span>s<span style="color: #6276ba;">[</span><span style="color: #008b8b;">0</span><span style="color: #6276ba;">]</span>, parse_input_t<span style="color: #6276ba;">(</span>s.data<span style="color: #858580;">()</span>+<span style="color: #008b8b;">1</span>, s.size<span style="color: #858580;">()</span>-<span style="color: #008b8b;">1</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>;
    <span style="color: #909183;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orgd14554e">
<h3 id="orgd14554e">More useful primitive parsers</h3>
<p>
And you can imagine how to write these.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">the opposite of one_of: match a char that isn't any of the given set</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">none_of</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">chars</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    ...
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>

<span style="color: #bebebe;">// </span><span style="color: #bebebe;">match a given string</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_string_parser</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">str</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">here we could use a constexpr version of std::mismatch...</span>
    ...
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orga553460">
<h3 id="orga553460">Building up</h3>
<p>
<br />
So far we have a few primitive parsers.<br />
<br />
<br />
In order to simply build up more complex parsers, we need to be able to<br />
<b>combine</b> parsers in various ways.
</p>

</section>
<section id="slide-orgd421bf6">
<h3 id="orgd421bf6">Building up</h3>
<p>
Some basic things we will want to do:
</p>

<ul>
<li>Change the result type of a parser (<code>fmap</code>)</li>
<li>Run one parser, then a second one based on what the first returned (<code>bind</code>)</li>
<li>Run one parser, and if it fails run another (<code>operator|</code>)</li>
<li>Run two parsers in succession and combine the outputs (<code>combine</code>)</li>

</ul>

<p>
(Pick your functional pattern: functor, monad, monoid, applicative&#x2026;)
</p>

<aside class="notes">
<p>
Some suggested names for the operations involved.
</p>

<p>
"Change the result type" = run a function on the result to turn it into something else.
</p>

<p>
<code>operator|</code> is the monoid operation (with the parser that always fails as the unit).
</p>

<p>
<code>combine</code> is the applicative operation.
</p>

<p>
I'll show you a few of these combinators so you can get a feel for them.
</p>

</aside>

</section>
<section id="slide-orgea66033">
<h3 id="orgea66033">Changing the result type (<code>fmap</code>)</h3>
<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #0000ff;">fmap</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">(</span>a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">fmap</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span>, <span style="color: #228b22;">P</span>&amp;&amp; <span style="color: #a0522d;">p</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">R</span> = <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">result_of_t</span><span style="color: #909183;">&lt;</span><span style="color: #0000ff;">F</span><span style="color: #709870;">(</span><span style="color: #228b22;">parse_t</span><span style="color: #907373;">&lt;</span><span style="color: #228b22;">P</span><span style="color: #907373;">&gt;</span><span style="color: #709870;">)</span><span style="color: #909183;">&gt;</span><span style="color: #7388d6;">&gt;</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>f = <span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #909183;">&gt;(</span>f<span style="color: #909183;">)</span>,
          p = <span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">P</span><span style="color: #909183;">&gt;(</span>p<span style="color: #909183;">)</span><span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> -&gt; R <span style="color: #7388d6;">{</span>
           <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r = p<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
           <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>!r<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
           <span style="color: #a020f0;">return</span> R<span style="color: #909183;">(</span><span style="color: #008b8b;">cx</span>::make_pair<span style="color: #709870;">(</span>f<span style="color: #907373;">(</span>r-&gt;first<span style="color: #907373;">)</span>, r-&gt;second<span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
         <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
<code>parse_t</code> here is just a way of getting the parsed type back out of the parser
without all the optional/pair business.
</p>

<p>
Note what fmap returns is a parser.
</p>

<p>
Think about a simple case of turning a char into an int.
</p>

</aside>

</section>
<section id="slide-orgeb89a88">
<h3 id="orgeb89a88">Alternation (<code>operator|</code>)</h3>
<div class="org-src-container">

<pre  class="src src-haskell">operator<span style="color: #0000ff;">|</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P2</span>,
          <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">enable_if_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_same_v</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #709870;">&gt;</span>, <span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #709870;">&gt;</span><span style="color: #909183;">&gt;</span>, <span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span> = <span style="color: #008b8b;">0</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">|</span><span style="color: #707183;">(</span>P1&amp;&amp; p1, P2&amp;&amp; p2<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r1 = p1<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>r1<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> r1;
    <span style="color: #a020f0;">return</span> p2<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">fail</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span>parse_input_t<span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Alternation is the monoid operation. <code>fail</code> is the identity.
</p>

</aside>

</section>
<section id="slide-org4a8d955">
<h3 id="org4a8d955">Conjunction (<code>combine</code>)</h3>
<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #0000ff;">combine</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>a <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> c<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> c
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P2</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">R</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">result_of_t</span><span style="color: #7388d6;">&lt;</span>F<span style="color: #909183;">(</span><span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #709870;">&gt;</span>, <span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #709870;">&gt;</span><span style="color: #909183;">)</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">combine</span><span style="color: #707183;">(</span><span style="color: #228b22;">P1</span>&amp;&amp; <span style="color: #a0522d;">p1</span>, <span style="color: #228b22;">P2</span>&amp;&amp; <span style="color: #a0522d;">p2</span>, <span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">R</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
           <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r1 = p1<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
           <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>!r1<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
           <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r2 = p2<span style="color: #909183;">(</span>r1-&gt;second<span style="color: #909183;">)</span>;
           <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>!r2<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
           <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #909183;">&lt;</span><span style="color: #228b22;">R</span><span style="color: #909183;">&gt;(</span>
               <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #709870;">(</span>f<span style="color: #907373;">(</span>r1-&gt;first, r2-&gt;first<span style="color: #907373;">)</span>, r2-&gt;second<span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
         <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
<code>combine</code> is a bit like <code>fmap</code> for multiple-argument functions. In some sense
the applicative operation.
</p>

<p>
Note that both parsers need to succeed, and we run the second parser on what is
leftover from the first, then return what is leftover from the second.
</p>

</aside>

</section>
<section id="slide-org0e9b1e9">
<h3 id="org0e9b1e9">Useful <code>combine</code> patterns</h3>
<div class="org-src-container">

<pre  class="src src-haskell">operator<span style="color: #0000ff;">&gt;</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a
operator<span style="color: #0000ff;">&lt;</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P2</span>,
          <span style="color: #a020f0;">typename</span> = <span style="color: #228b22;">parse_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #a020f0;">typename</span> = <span style="color: #228b22;">parse_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span><span style="color: #707183;">(</span>P1&amp;&amp; p1, P2&amp;&amp; p2<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> combine<span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #909183;">&gt;(</span>p1<span style="color: #909183;">)</span>,
                 <span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #909183;">&gt;(</span>p2<span style="color: #909183;">)</span>,
                 <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">auto</span>, <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span>&amp; <span style="color: #a0522d;">r</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span> <span style="color: #a020f0;">return</span> r; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
These operators are useful for throwing away the left or right hand side of <code>combine</code>.
</p>

<aside class="notes">
<p>
These simple formulations of combine are very useful. They allow us to run
multiple parsers in succession, keeping just the left hand side or the right
hand side.
</p>

<p>
And of course the operators are symmetric and left-associative.
</p>

</aside>

</section>
<section id="slide-orgb421e22">
<h3 id="orgb421e22">Accumulating combinators</h3>
<p>
And now you begin to see where this is heading&#x2026;
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #0000ff;">many</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span>  <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
<span style="color: #0000ff;">many1</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span>  <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
<span style="color: #0000ff;">exactly_n</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> int <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
<span style="color: #0000ff;">separated_by</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> x <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
</pre>
</div>

<p>
These are starting to look like building blocks we can use to parse real things.
</p>

<aside class="notes">
<p>
Explain each of these function signatures.
</p>

</aside>

</section>
<section id="slide-orgdf4f823">
<h3 id="orgdf4f823">Some simple examples</h3>
<p>
This parser eats whitespace.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">skip_whitespace</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> ws_parser =
    make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">' '</span><span style="color: #7388d6;">)</span>
    | make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">t</span><span style="color: #b22222;">'</span><span style="color: #7388d6;">)</span>
    | make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">n</span><span style="color: #b22222;">'</span><span style="color: #7388d6;">)</span>
    | make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">r</span><span style="color: #b22222;">'</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> many<span style="color: #7388d6;">(</span>ws_parser, <span style="color: #008b8b;">std</span>::monostate<span style="color: #909183;">{}</span>, <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">m</span>, <span style="color: #a020f0;">auto</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span> <span style="color: #a020f0;">return</span> m; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Alternation of each individual parser. (Also, we could use <code>one_of</code> here.)
</p>

<p>
Then many (zero or more) of the resulting parser.
</p>

<p>
The key to all the combinators is that what they return are themselves parsers.
Composition!
</p>

</aside>

</section>
<section id="slide-orgdde7c85">
<h3 id="orgdde7c85">Some simple examples</h3>
<p>
This parses a decimal integer.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">int_parser</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> bind<span style="color: #7388d6;">(</span>one_of<span style="color: #909183;">(</span><span style="color: #b22222;">"</span><span style="color: #b22222;">123</span><span style="color: #b22222; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">456</span><span style="color: #b22222;">789</span><span style="color: #b22222;">"</span>sv<span style="color: #909183;">)</span>,
              <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #228b22;">char</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">rest</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
                <span style="color: #a020f0;">return</span> many<span style="color: #709870;">(</span>one_of<span style="color: #907373;">(</span><span style="color: #b22222;">"</span><span style="color: #b22222; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">0</span><span style="color: #b22222;">123</span><span style="color: #b22222; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">456</span><span style="color: #b22222;">789</span><span style="color: #b22222;">"</span>sv<span style="color: #907373;">)</span>,
                            <span style="color: #a020f0;">static_cast</span><span style="color: #907373;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #907373;">&gt;(</span>x - <span style="color: #b22222;">'0'</span><span style="color: #907373;">)</span>,
                            <span style="color: #907373;">[]</span> <span style="color: #907373;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">acc</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #907373;">)</span> <span style="color: #907373;">{</span> <span style="color: #a020f0;">return</span> <span style="color: #6276ba;">(</span><span style="color: #228b22;">acc</span>*<span style="color: #008b8b;">10</span><span style="color: #6276ba;">)</span> + <span style="color: #6276ba;">(</span>c-<span style="color: #b22222;">'0'</span><span style="color: #6276ba;">)</span>; <span style="color: #907373;">}</span><span style="color: #709870;">)(</span>rest<span style="color: #709870;">)</span>;
              <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
First any non-zero digit, then zero or more digits,<br />
building up the integer in the obvious way.
</p>

<aside class="notes">
<p>
Note that <code>bind</code>'s second argument carries the leftover string through as well
as the parse result of the first argument.
</p>

</aside>

</section>
<section id="slide-orgab0ca66">
<h3 id="orgab0ca66">Some simple examples</h3>
<p>
This (very simply) parses a string.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">string_parser</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> quote_parser = make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'"'</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> str_parser =
    many<span style="color: #7388d6;">(</span>none_of<span style="color: #909183;">(</span><span style="color: #b22222;">"</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">"</span><span style="color: #b22222;">"</span>sv<span style="color: #909183;">)</span>,
         <span style="color: #008b8b;">std</span>::string_view<span style="color: #909183;">(</span>s.data<span style="color: #709870;">()</span>+<span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">0</span><span style="color: #909183;">)</span>,
         <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span>&amp; <span style="color: #a0522d;">acc</span>, <span style="color: #a020f0;">auto</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
           <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">(</span>acc.data<span style="color: #907373;">()</span>, acc.size<span style="color: #907373;">()</span>+<span style="color: #008b8b;">1</span><span style="color: #709870;">)</span>;
         <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #228b22;">quote_parser</span> <span style="color: #7388d6;">&lt;</span> str_parser <span style="color: #7388d6;">&gt;</span> quote_parser;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
For the sake of simplicity, we aren't dealing with escaped characters, unicode
points, etc.
</p>

<p>
In fact for this simple example we are accumulating a <code>string_view</code>. But in
general when we come to parse escaped characters, the input characters don't
have a 1-to-1 mapping with the output characters.
</p>

</aside>

</section>
<section id="slide-org397d2da">
<h3 id="org397d2da">Getting to JSON</h3>
<p>
We now have a toolkit for building parsers.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span>=<span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  ...
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">boolean</span><span style="color: #909183;">{</span><span style="color: #008b8b;">false</span><span style="color: #909183;">}</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span><span style="color: #909183;">{</span><span style="color: #008b8b;">0</span><span style="color: #909183;">}</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span> <span style="color: #a0522d;">string</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span>, <span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>
<p>
To parse our JSON value, a reasonable approach is to use<br />
alternation on parsers for each type of value.
</p>

<aside class="notes">
<p>
We're going to have 6 different parsers, each of which produces a <code>JSON_Value</code>,
and we're going to alternate them together.
</p>

<p>
They will be mutually recursive: the parsers for objects and arrays call the
value parsers.
</p>

<p>
In order to achieve mutual recursion, we'll put them in a struct. (The next
couple of slides contain a lot of code - sorry.)
</p>

</aside>

</section>
<section id="slide-org4958ed1">
<h3 id="org4958ed1">Recursive parsing structure</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">recur</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #7388d6;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">value_parser</span><span style="color: #7388d6;">()</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> p =
      fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span><span style="color: #008b8b;">std</span>::monostate<span style="color: #6276ba;">{}</span><span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
           make_string_parser<span style="color: #709870;">(</span><span style="color: #b22222;">"null"</span>sv<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span><span style="color: #008b8b;">true</span><span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             make_string_parser<span style="color: #709870;">(</span><span style="color: #b22222;">"true"</span>sv<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span><span style="color: #008b8b;">false</span><span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             make_string_parser<span style="color: #709870;">(</span><span style="color: #b22222;">"false"</span>sv<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">n</span><span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span>n<span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             number_parser<span style="color: #709870;">()</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">str</span><span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span>str<span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             string_parser<span style="color: #709870;">()</span><span style="color: #909183;">)</span>
      | array_parser<span style="color: #909183;">&lt;</span>Depth<span style="color: #909183;">&gt;()</span>
      | object_parser<span style="color: #909183;">&lt;</span>Depth<span style="color: #909183;">&gt;()</span>;
    <span style="color: #a020f0;">return</span> skip_whitespace<span style="color: #909183;">()</span> &lt; p;
  <span style="color: #7388d6;">}</span>
  ...
</pre>
</div>

<aside class="notes">
<p>
<code>value_parser</code> is the top level entry point to our parser.
</p>

<p>
Each argument of alternation must return the same type: in this case, they are
<code>JSON_Value</code> parsers, obtained from each other parse type by fmapping in an
appropriate function.
</p>

<p>
Note the way we eat whitespace before a value. Easy with the applicative
operator. It would be "easy" to sprinkle <code>skip_whitespace()</code> everywhere and it
would work&#x2026; but a more disciplined approach is to eating whitespace <b>before</b>
the parses that need it.
</p>

</aside>

</section>
<section id="slide-orgbaf91a8">
<h3 id="orgbaf91a8">Recursive parsing structure</h3>
<div class="org-src-container">

<pre  class="src src-c++">  ...
  <span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #707183;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> array_parser<span style="color: #707183;">()</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>

  <span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #707183;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">key_value_parser</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>

  <span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #707183;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">object_parser</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>
<span style="color: #88090B;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #88090B;">&lt;&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #008b8b;">recur</span>::<span style="color: #0000ff;">value_parser</span><span style="color: #88090B;">&lt;</span><span style="color: #008b8b;">0</span><span style="color: #88090B;">&gt;()</span> <span style="color: #88090B;">{</span>
  <span style="color: #a020f0;">return</span> fail<span style="color: #707183;">(</span><span style="color: #228b22;">JSON_Value</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">&gt;{}</span><span style="color: #707183;">)</span>;
<span style="color: #88090B;">}</span>

<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span> <span style="color: #b22222;">""</span> _json<span style="color: #88090B;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">str</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span><span style="color: #88090B;">)</span> <span style="color: #88090B;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">recur</span>::value_parser<span style="color: #707183;">&lt;&gt;()(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #7388d6;">{</span>str, len<span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
<span style="color: #88090B;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The body of everything is too much code to show, but you can imagine how these
work.
</p>

<p>
For <code>array_parser</code>, we parse an open square bracket, then we use our
<code>separated_by</code> combinator to parse values separated by commas, then we parse a
closing square bracket. The JSON value we return is an array type value which
has had its array member accumulated with the comma-separated values we parsed.
</p>

<p>
Object parser is similar, but open/close curly braces, and key-value pairs
separated by commas. A key-value pair is itself a string followed by a colon
followed by a value.
</p>

<p>
Each time we recurse through <code>value_parser</code>, we decrement the <code>Depth</code>
template value to produce the next level of the JSON tree.
</p>

<p>
Note the use of <code>fail</code>: an easy way to provide the right type for the base case.
</p>

</aside>

</section>
<section id="slide-orgbd92cde">
<h3 id="orgbd92cde">Error messages</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">ErrorFn</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">fail</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span>, <span style="color: #228b22;">ErrorFn</span> <span style="color: #a0522d;">f</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span>parse_input_t<span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    f<span style="color: #909183;">()</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">array_parser</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> ...
    &gt; <span style="color: #7388d6;">(</span>make_char_parser<span style="color: #909183;">(</span><span style="color: #b22222;">']'</span><span style="color: #909183;">)</span> | fail<span style="color: #909183;">(</span><span style="color: #b22222;">']'</span>, <span style="color: #709870;">[]</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">throw</span> <span style="color: #b22222;">"expected ]"</span>; <span style="color: #709870;">}</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
It's not a very good story.
</p>

<aside class="notes">
<p>
Support for error messages during compile time parsing is very rudimentary.
</p>

<p>
This is the best I came up with: a fail parser that will throw and cause a
compile error. So it sort of tells you what went wrong, and probably tells you
the line the malformed literal is on, but it can't tell you anything about where
in the parse the error was.
</p>

<p>
A bit more about this later.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge835680">
<h2 id="orge835680">Parsing JSON Value Literals (Better)</h2>
<p>
<br />
What we have so far is the simplest proof-of-concept.<br />
<br />
<br />
It works (for suitable values of "works").<br />
<br />
<br />
It's a good starting point, but there are a few problems we need to address.
</p>

<aside class="notes">
<p>
What we have so far is a good starting point. The parsing toolkit is pretty useful.
</p>

</aside>

</section>
<section id="slide-org7432438">
<h3 id="org7432438">Problem 1: A JSON number isn't an <code>int</code></h3>

<div class="figure">
<p><img src="./json_number.png" alt="json_number.png" />
</p>
</div>

<aside class="notes">
<p>
From json.org
</p>

<p>
A json number is considerably more complex to parse than an int.
</p>

<p>
But this can be done&#x2026;
</p>

<p>
You can see here we have some optional values in the parse. <code>option</code> is a useful
combinator to add for that. (Run a parser, and if it fails, return a default value.)
</p>

</aside>

</section>
<section id="slide-org4afded0">
<h3 id="org4afded0">Problem 2: A JSON string isn't a <code>string_view</code></h3>

<div class="figure">
<p><img src="./json_string.png" alt="json_string.png" />
</p>
</div>

<aside class="notes">
<p>
Strings are quite tricky to parse actually.
</p>

<p>
Non-unicode escaped characters aren't especially hard. We can use <code>operator&lt;</code> to
match and discard a slash, then convert the following character appropriately.
Unicode characters are a little more exacting.
</p>

<p>
The essential point here is that we can't get away with just outputting part of
the <code>string_view</code> that was the input. Parsing strings actually involves
transforming the input into a different, and differently-sized, output.
</p>

<p>
But again, we have all the tools to do this.
</p>

</aside>

</section>
<section id="slide-orge579b83">
<h3 id="orge579b83">Problem 3: Template instantiation</h3>
<div class="org-src-container">

<pre  class="src src-bash">$ time make
<span style="color: #707183;">[</span> <span style="color: #008b8b;">50%</span><span style="color: #707183;">]</span> Building CXX object main.cpp.o
<span style="color: #707183;">[</span><span style="color: #008b8b;">100%</span><span style="color: #707183;">]</span> Linking CXX executable constexpr-all-the-things
<span style="color: #707183;">[</span><span style="color: #008b8b;">100%</span><span style="color: #707183;">]</span> Build target constexpr-all-the-things

real    A BLOODY...
user     LONG...
sys       TIME
$
</pre>
</div>

<aside class="notes">
<p>
We need to get rid of some templates.
</p>

</aside>

</section>
<section id="slide-orgcb3af36">
<h3 id="orgcb3af36">Problem 4: Arbitrary Limits</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_parse_depth</span><span style="color: #707183;">{</span><span style="color: #008b8b;">3</span><span style="color: #707183;">}</span>;

<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_vector_size</span><span style="color: #707183;">{</span><span style="color: #008b8b;">6</span><span style="color: #707183;">}</span>;
<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_map_size</span><span style="color: #707183;">{</span><span style="color: #008b8b;">6</span><span style="color: #707183;">}</span>;

<span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">cx</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">string</span> = <span style="color: #228b22;">basic_string</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span>, <span style="color: #008b8b;">32</span><span style="color: #7388d6;">&gt;</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Nobody likes arbitrary limits. And these are some pretty small limits, at that.
</p>

</aside>

</section>
<section id="slide-orgedd7ceb">
<h3 id="orgedd7ceb">Getting Rid Of Template Slowness</h3>
<p>
All this recursive templatery is a problem.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span>=<span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    ...
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::static_string, <span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orga17deca">
<h3 id="orga17deca">Solution: More Parsing!</h3>
<p>
<br />
What we have is a parser for JSON values.<br />
<br />
But we could create more parsers&#x2026;<br />
<br />
</p>
<p class="fragment (appear)">
How about a parser for the <b>number</b> of JSON values required?
</p>

<aside class="notes">
<p>
Of course a parser can produce anything: it doesn't have to produce just JSON
values. If we could parse out the number of values required by a literal, we
could right-size an array of JSON values and then do another pass over the
literal with our actual value parser, outputting into the array.
</p>

</aside>

</section>
<section id="slide-orgca4a87a">
<h3 id="orgca4a87a">Number-of-values Parser</h3>
<p>
We can write a parser that computes the number of values in a literal:
</p>

<ul>
<li>Array -&gt; 1 + number of values in children</li>
<li>Object -&gt; 1 + number of values in children</li>
<li>Everything else -&gt; 1</li>

</ul>

<p>
We can reuse some structural components of our value parser, and a
number-of-values parser is simpler in many places.
</p>

</section>
<section id="slide-orgd64de7a">
<h3 id="orgd64de7a">Number-of-values Parser</h3>
<p>
Take the recursive function templates out of our value parser: instead, the
struct itself is a template containing the right-sized array of values.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">recur</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">V</span> = <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #7388d6;">&lt;</span>JSON_Value, N<span style="color: #7388d6;">&gt;</span>;
  <span style="color: #228b22;">V</span> <span style="color: #a0522d;">vec</span><span style="color: #7388d6;">{}</span>;

  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">recur</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    value_parser<span style="color: #909183;">(</span>vec<span style="color: #909183;">)(</span>s<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>

  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">value_parser</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">V</span>&amp; <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
A major source of compilation slowness was instantiating the parser function
templates.
</p>

<p>
The parser functions now do much the same as before except they <code>push_back</code> the
parsed values into the array. And they <code>return</code> the array index of the element
they created.
</p>

<p>
We do the parsing on construction just to make things easy.
</p>

</aside>

</section>
<section id="slide-org03602aa">
<h3 id="org03602aa">Non-templated <code>JSON_Value</code></h3>
<p>
Now we can have a <code>JSON_Value</code> that isn't a template.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    ...
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">std</span>::size_t, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::static_string, <span style="color: #008b8b;">std</span>::size_t, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

<p>
The array and object values store offsets into the externalized array.
</p>

<aside class="notes">
<p>
Now that we have externalized the storage of the values, the arrays and objects
inside the <code>JSON_Value</code> store the offsets of their children.
</p>

<p>
I tried having them store pointers to JSON<sub>Values</sub>, but that didn't work
<code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-org8d15ee9">
<h3 id="org8d15ee9">Example parse</h3>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsval = <span style="color: #b22222;">"[1, [2, 3], 4]"</span>_json;
</pre>
</div>
<p>
<br />
Number of values: 6 (2 arrays, 4 numbers)<br />
<br />
<object type="image/svg+xml" data="./array_diagram.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<aside class="notes">
<p>
Note the offset numbers for the array(s) here. They are not indices into the
external storage yet, they are just offsets from the current.
</p>

</aside>

</section>
<section id="slide-org16d8165">
<h3 id="org16d8165">Driving the Parse</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">char</span>... <span style="color: #a0522d;">Cs</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">numobjects</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">initializer_list</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">il</span><span style="color: #7388d6;">{</span>Cs...<span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">numobjects_recur</span><span style="color: #7388d6;">&lt;&gt;</span>::value_parser<span style="color: #7388d6;">()(</span>
      <span style="color: #008b8b;">std</span>::string_view<span style="color: #909183;">(</span>il.begin<span style="color: #709870;">()</span>, il.size<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>-&gt;first;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>, <span style="color: #228b22;">T</span>... <span style="color: #a0522d;">Ts</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span> <span style="color: #b22222;">""</span> _json<span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">initializer_list</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">il</span><span style="color: #7388d6;">{</span>Ts...<span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> recur<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">numobjects</span><span style="color: #909183;">&lt;</span>Ts...<span style="color: #909183;">&gt;()</span><span style="color: #7388d6;">&gt;(</span>
      <span style="color: #008b8b;">std</span>::string_view<span style="color: #909183;">(</span>il.begin<span style="color: #709870;">()</span>, il.size<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>.vec;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
In order to get "constexpr arguments" we have to switch to the template version
of the literal operator (gnu extension based on N3599). That way we can pass the
template arguments on to our numobjects parser.
</p>

<p>
Note we're making a <code>string_view</code> out of the <code>initializer_list</code> expansion.
</p>

<p>
What's returned from the top-level parse is the vector of values. The "root"
value is at index 0.
</p>

</aside>

</section>
<section id="slide-orgf7d88f6">
<h3 id="orgf7d88f6">Problem 3: Solved</h3>
<p>
<br />
Cost: an extra pass<br />
<br />
Benefits:
</p>
<ul>
<li>quicker compilation (no recursive templates!)</li>
<li>no arbitrary hardcoded limit to depth</li>

</ul>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsval = <span style="color: #b22222;">"([[[[[[[[[[[[1]]]]]]]]]]]])"</span>_json;
static_assert<span style="color: #707183;">(</span>jsval<span style="color: #7388d6;">[</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">]</span>.to_Number<span style="color: #7388d6;">()</span> == <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
The cost of the extra pass is much less than the cost of instantiating recursive
templates, especially since the number-of-values parser is much simpler than
the full parser.
</p>

<p>
And arbitrary depth is a significant win.
</p>

</aside>

</section>
<section id="slide-orgde22698">
<h3 id="orgde22698">Problem 4: Arbitrary limits</h3>
<p>
We still have limits on:
</p>

<ul>
<li>string size</li>
<li>array size</li>
<li>object (map) size</li>

</ul>

<p class="fragment appear">
Can we use the same strategy of precomputing size to combat these?
</p>

</section>
<section id="slide-org4e01df1">
<h3 id="org4e01df1">Removing string size restriction</h3>
<p>
We <b>can</b> use the same technique:
</p>
<ul>
<li class="fragment appear">precompute the total string size for the value</li>
<li class="fragment appear">rightsize a char buffer</li>
<li class="fragment appear">store <code>{offset, extent}</code> in the string <code>JSON_Value</code> as we parse</li>

</ul>
<p>
<br />
<br />
</p>
<p class="fragment appear">
We can do the number-of-values and total-string-size computation in a single
pass<br />
(that returns the pair of sizes).
</p>

<aside class="notes">
<p>
Structural bindings don't work <code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-orgc6593b7">
<h3 id="orgc6593b7">String size limit removed</h3>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsval = R<span style="color: #b22222;">"(["</span>X<span style="color: #b22222;">", ["</span>ALL<span style="color: #b22222;">", "</span>the<span style="color: #b22222;">"], "</span>things!<span style="color: #b22222;">"])"</span>_json;
</pre>
</div>
<p>
<br />
Number of values: 6 (2 arrays, 4 strings)<br />
Total string size: 14 (1 + 3 + 3 + 7)<br />
<br />
<object type="image/svg+xml" data="./string_size_diagram.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

</section>
<section id="slide-org219b23b">
<h3 id="org219b23b">Remaining limits</h3>
<p>
We still have limits on:
</p>

<ul>
<li>array size</li>
<li>object (map) size</li>

</ul>

<p>
We can't naively do the same thing we did with strings, because values within
arrays/objects aren't contiguous.
</p>

<aside class="notes">
<p>
We would like to be able to represent arrays as <code>{offset, extent}</code> but this is
only possible if the values contained within the array are stored contiguously.
</p>

</aside>

</section>
<section id="slide-org094b33f">
<h3 id="org094b33f">Arrays/Objects Aren't Contiguous</h3>
<p>
As we saw before, because of arbitrary nesting.
<br />
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsval = <span style="color: #b22222;">"[1, [2, 3], 4]"</span>_json;
</pre>
</div>
<p>
<br />
<object type="image/svg+xml" data="./array_diagram.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<aside class="notes">
<p>
This is because of the inherent depth-first traversal of parsing.
</p>

<p>
So how can we make the storage of the compound values contiguous?
</p>

</aside>

</section>
<section id="slide-org2e3319e">
<h3 id="org2e3319e">Add another pass</h3>
<p>
Add a pass to make the parser "breadth-first".
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">union</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">unparsed</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">boolean</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span>;
    ...
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
We're parsing a <code>string_view</code> that represents a JSON value. Every JSON value
contained is a <code>string_view</code> inside the top-level <code>string_view</code>.
</p>

<p>
All we need is a parser that returns the <code>string_view</code> for its value. We can
then use it to parse the children of the array value and store each as an
unparsed <code>string_view</code>. Contiguously!
</p>

<p>
What was earlier <code>struct</code> is <code>union</code> here.
</p>

</aside>

</section>
<section id="slide-orgc6a9f64">
<h3 id="orgc6a9f64">"Breadth-first" Parsing</h3>
<p>
Now the array is parsed contiguously.
<br />
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsval = <span style="color: #b22222;">"[1, [2, 3], 4]"</span>_json;
</pre>
</div>
<p>
<br />
<object type="image/svg+xml" data="./breadth_first_diagram.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<aside class="notes">
<p>
The diagram shows the intermediate stage of parsing the array. The array is
stored as offset + extent.
</p>

<p>
Once the array is parsed so that its immediate children occupy contiguous
storage, we go back and parse its children again into "real" JSON values that
are appended in the storage.
</p>

</aside>

</section>
<section id="slide-orga8628e3">
<h3 id="orga8628e3">As Arrays, so Objects</h3>
<p>
<br />
Arrays are now <code>{offset, extent}</code>, so there is no limit on array size.<br />
<br />
Objects could be arrays of (string, value).<br />
<br />
We just need to deal with object keys.
</p>

<aside class="notes">
<p>
There is one remaining limit: the size of an object key (because it's a string).
</p>

<p>
Well, now JSON values are small, and can store arbitrary length strings&#x2026; so we
might as well store an object key as a JSON value.
</p>

</aside>

</section>
<section id="slide-orga2d0716">
<h3 id="orga2d0716">Object storage</h3>
<p>
Objects are alternating strings and arbitrary values.
<br />
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsval = R<span style="color: #b22222;">"({"</span>McKern<span style="color: #b22222;">":2,  "</span>McGoohan<span style="color: #b22222;">":6})"</span>_json;
</pre>
</div>
<p>
<br />
<object type="image/svg+xml" data="./object_diagram.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

<aside class="notes">
<p>
Of course, 6 here should really be NaN. Perhaps that's another talk :)
</p>

</aside>

</section>
<section id="slide-orgbd9c382">
<h3 id="orgbd9c382">Finally, no limits!</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">ExternalView</span> <span style="color: #7388d6;">{</span>
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">offset</span>;
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">extent</span>;
  <span style="color: #7388d6;">}</span>;

  <span style="color: #a020f0;">union</span> <span style="color: #228b22;">Data</span> <span style="color: #7388d6;">{</span>
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">unparsed</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">boolean</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span>;
    <span style="color: #228b22;">ExternalView</span> <span style="color: #a0522d;">external_string</span>;
    <span style="color: #228b22;">ExternalView</span> <span style="color: #a0522d;">external_array</span>;
    <span style="color: #228b22;">ExternalView</span> <span style="color: #a0522d;">external_object</span>;
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
This is the final representation of a JSON value as produced by our parsing
scheme.
</p>

</aside>

</section>
<section id="slide-org775b611">
<h3 id="org775b611">Parsing: Conclusion</h3>
<ul>
<li class="fragment appear"><code>constexpr</code> lambdas enable composable compile-time parsing</li>
<li class="fragment appear">parser combinators enable more complex literals</li>
<li class="fragment appear">multiple passes can be used thanks to template UDL operators and <code>string_view</code></li>
<li class="fragment appear">adding extra passes can solve almost any problem&#x2026;</li>
<li class="fragment appear">could parsing be helped by a (good?) C++ concept?</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf0290a4">
<h2 id="orgf0290a4">The Future</h2>
<aside class="notes">
<p>
Jason to talk through this section.
</p>

</aside>

</section>
<section id="slide-orgeee49ad">
<h3 id="orgeee49ad">The destructor problem</h3>
<p>
Currently any type with a non-trivial destructor cannot be used in <code>constexpr</code> context.
</p>

<p>
trivially destructible quiz time!
</p>

</section>
<section id="slide-org838ff19">
<h3 id="org838ff19"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-orgc9214b8">
<h3 id="orgc9214b8"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>;
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org400cf01">
<h3 id="org400cf01"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">i</span>;
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org86bf8de">
<h3 id="org86bf8de"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
  ~<span style="color: #0000ff;">S</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{}</span>
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
If we put "~S() = default;" then that <i>is</i> trivially destructible.
</p>

</aside>

</section>
<section id="slide-orgc9b6ce6">
<h3 id="orgc9b6ce6">Why is this a problem?</h3>
<p>
It's easy to build a <code>constexpr</code> enabled type that can grow at runtime,<br />
or fail to compile if it gets too big in <code>constexpr</code> context.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Container</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #008b8b;">10</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">data</span><span style="color: #7388d6;">{}</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">length</span> = <span style="color: #008b8b;">0</span>;
  <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">extra_data</span> = <span style="color: #008b8b;">nullptr</span>;
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>length &gt;= data.size<span style="color: #709870;">()</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">if</span> <span style="color: #709870;">(</span>!extra_data<span style="color: #709870;">)</span> <span style="color: #709870;">{</span>
        extra_data = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">int</span><span style="color: #907373;">[</span><span style="color: #008b8b;">100</span><span style="color: #907373;">]</span>;
      <span style="color: #709870;">}</span>
      extra_data<span style="color: #709870;">[</span><span style="color: #907373;">(</span>length++<span style="color: #907373;">)</span> - data.size<span style="color: #907373;">()</span><span style="color: #709870;">]</span> = i;
    <span style="color: #909183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #909183;">{</span>
      data<span style="color: #709870;">[</span>length++<span style="color: #709870;">]</span> = i;
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgb654c3d">
<h3 id="orgb654c3d">Why is this a problem?</h3>
<p>
<b>But</b>: as soon as we add a destructor, the class is no longer usable in a <code>constexpr</code> context.
</p>

<p>
So we can build this type, but we are required to leak memory<br />
if it grows beyond the static size!
</p>

</section>
<section id="slide-org1e30605">
<h3 id="org1e30605">Solutions to the <code>constexpr</code> destructor problem</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Container</span> <span style="color: #707183;">{</span>
  ~<span style="color: #0000ff;">Container</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">this proposal allows for an empty destructor to be allowed</span>
    <span style="color: #a020f0;">if</span> <span style="color: #a020f0;">constexpr</span><span style="color: #909183;">(</span>something<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #bebebe;">// </span><span style="color: #bebebe;">do something</span>
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgc2fcfa0">
<h3 id="orgc2fcfa0">Solutions to the <code>constexpr</code> destructor problem</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Container</span> <span style="color: #707183;">{</span>
  ~<span style="color: #0000ff;">Container</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">but why not treat it like any other constexpr code?</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">allow it as long as only constexpr allowed actions</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">happen at compile time?</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>extra_data<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">delete</span> <span style="color: #709870;">[]</span> extra_data;
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org4c0816a">
<h3 id="org4c0816a">The debugging problem</h3>
<p>
On which line does GCC report an error?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span class="linenr"> 1: </span><span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">int</span> <span style="color: #0000ff;">do_something</span><span style="color: #707183;">()</span>
<span class="linenr"> 2: </span><span style="color: #707183;">{</span>
<span class="linenr"> 3: </span>  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">val</span><span style="color: #7388d6;">[</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">]{}</span>;
<span class="linenr"> 4: </span>  <span style="color: #a020f0;">return</span> val<span style="color: #7388d6;">[</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">]</span>;
<span class="linenr"> 5: </span><span style="color: #707183;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span>
<span class="linenr"> 8: </span><span style="color: #707183;">{</span>
<span class="linenr"> 9: </span>  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> val = do_something<span style="color: #7388d6;">()</span>;
<span class="linenr">10: </span><span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org7301e02">
<h3 id="org7301e02">The debugging problem</h3>
<p>
Several times during debugging we had to take the code from compile time context 
to runtime context to allow for actual debugging.
</p>

<aside class="notes">
<p>
In building the data structure, switching to runtime context was useful.
</p>

<p>
In building up parsers, it was mostly simplify expressions and puzzle over the types.
</p>

</aside>

</section>
<section id="slide-org1480d81">
<h3 id="org1480d81">The debugging problem</h3>
<p>
This proposal adds debugging capability at compile time.
</p>


<div class="figure">
<p><img src="./constexpr_trace.png" alt="constexpr_trace.png" />
</p>
</div>

<aside class="notes">
<p>
This would be useful for reporting parse errors on <code>constexpr</code> literals.
</p>

</aside>

</section>
<section id="slide-orgd470866">
<h3 id="orgd470866"><code>constexpr_vector</code></h3>
<p>
This other proposal from the same author allows for a special type of <code>constexpr_vector</code>
that is allowed to grow and shrink at compile time only, requiring compiler support.
</p>


<div class="figure">
<p><img src="./constexpr_vector.png" alt="constexpr_vector.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgb72a68a">
<h2 id="orgb72a68a"><code>constexpr</code> STL possibilities</h2>
<div class="outline-text-2" id="text-orgb72a68a">
</div></section>
<section id="slide-org336e4f8">
<h3 id="org336e4f8">algorithms</h3>
<p>
<br />
Weakened complexity guarantees on <code>stable_sort</code>, <code>inplace_merge</code>, <code>stable_partition</code>?
(They make use of temporary buffers to improve complexity.)<br />
<br />
Are there others that might need to have<br />
weakened complexity guarantees for compile time use?
</p>

<aside class="notes">
<p>
The temporary buffers aren't required for the algorithms to be correct, merely
to make them efficient.
</p>

</aside>

</section>
<section id="slide-org2327ea4">
<h3 id="org2327ea4">iterators</h3>
<p>
If you have a <code>constexpr</code> container, you want the iterators to all be <code>constexpr</code>.
</p>

<p>
Many iterators could be <code>constexpr</code> and usable in a <code>constexpr</code> context<br />
if the operations on the corresponding containers are.
</p>

<p>
e.g. if you have <code>constexpr push_back</code> on your <code>constexpr vector</code> type,<br />
<code>back_insert_iterator</code> could easily be <code>constexpr</code>.
</p>

</section>
</section>
<section>
<section id="slide-org58f7bec">
<h2 id="org58f7bec">The Cost</h2>
<div class="outline-text-2" id="text-org58f7bec">
</div></section>
<section id="slide-orgca61cb0">
<h3 id="orgca61cb0">Cognitive Cost</h3>
<ul>
<li class="fragment appear">Flat data structures are easy to reason about</li>
<li class="fragment appear"><code>constexpr</code> code forces you to consider what your code is doing and the lifetime of objects (in a good way).</li>
<li class="fragment appear">Tree-like data structures are difficult to reason about</li>
<li class="fragment appear">Selecting data structure sizes can be difficult</li>
<li class="fragment appear">Error messages from heavily composed lambdas are&#x2026; challenging to deal with</li>
<li class="fragment appear">Debugging often currently means "go back and think about the types"</li>

</ul>

<aside class="notes">
<p>
Is recursive computation harder to reason about? It depends on the problem, I think.
</p>

</aside>

</section>
<section id="slide-org12ef5e5">
<h3 id="org12ef5e5">Compile-time Cost - Debug Build</h3>
<ul>
<li class="fragment appear">6GB RAM!</li>
<li class="fragment appear">&gt;2 Minutes Build Time</li>
<li class="fragment appear">338K Binary</li>
<li class="fragment appear">Tweaking debug level can have a great effect. This might be related to symbol sizes.</li>

</ul>

<aside class="notes">
<p>
Explain exactly <b>what</b> is being built here?
</p>

<p>
Changing -g3 to -g1 greatly improves build time/space.
</p>

</aside>

</section>
<section id="slide-org130b702">
<h3 id="org130b702">Compile-time Cost - Release Build</h3>
<ul>
<li class="fragment appear">328MB RAM</li>
<li class="fragment appear">5s Build Time</li>
<li class="fragment appear">9K Binary</li>

</ul>

<aside class="notes">
<p>
This is pretty acceptable, especially when you consider that you are potentially
replacing whole steps in the build chain, possibly reducing the need to maintain
code generation tools, and moving the one source of truth into the C++ itself.
</p>

</aside>

</section>
<section id="slide-org09f9dc2">
<h3 id="org09f9dc2">Compile-time Cost - Comparison</h3>
<p>
Using the same nightly build of GCC, how long does this take to compile?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #b22222;">regex</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">regex</span> <span style="color: #0000ff;">attribute</span><span style="color: #7388d6;">(</span>R<span style="color: #b22222;">"(\s+(\S+)\s*=\s*('|"</span><span style="color: #7388d6;">)(</span>.*?<span style="color: #7388d6;">)</span>\<span style="color: #008b8b;">2</span><span style="color: #88090B;">)</span><span style="color: #b22222;">");</span>
<span style="color: #b22222;">}</span>
</pre>
</div>

<p class="fragment (appear)">
5s Debug, 7.5s Release
</p>

<aside class="notes">
<p>
Slow build times are not unknown to the STL today.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orga15eaa2">
<h2 id="orga15eaa2">Conclusion</h2>
<ul>
<li class="fragment appear">All but 3 standard algorithms can (easily?) be made <code>constexpr</code></li>
<li class="fragment appear">There are holes around assignment operations in the STL</li>
<li class="fragment appear">Many iterator operations could be made <code>constexpr</code> for use with <code>constexpr</code> containers</li>
<li class="fragment appear">Some interaction with C, ie <code>&lt;cmath&gt;</code> may hold back some operations</li>
<li class="fragment appear"><code>constexpr</code> lambdas unlock the potential for complex UDLs</li>
<li class="fragment appear"><code>constexpr</code> allocators and <code>constexpr</code> destructors would make it possible to unify <code>constexpr</code> containers with regular ones</li>

</ul>

<p class="fragment appear">
Thanks!<br />
<a href="https://github.com/lefticus/constexpr_all_the_things" class="fragment appear">https://github.com/lefticus/constexpr_all_the_things</a>
</p>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
