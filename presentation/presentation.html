<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>constexpr ALL the things!</title>
<meta name="author" content="(Ben Deane & Jason Turner)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">constexpr ALL the things!</h1><h2 class="author">Ben Deane &amp; Jason Turner</h2><h2 class="email"><a href="mailto:bdeane@blizzard.com">bdeane@blizzard.com</a>, <a href="mailto:jason@emptycrate.com">jason@emptycrate.com</a></h2><h2 class="date">May 16th, 2017</h2>
</section>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org5a5b91b">
<h2 id="org5a5b91b">Don't Bury The Lede</h2>
<p>
We want to do this:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">constexpr</span> <span style="color: #a020f0;">auto</span> jsv
  = R<span style="color: #ff0000; font-weight: bold;">"</span><span style="color: #8b2252;">({</span>
<span style="color: #8b2252;">        "</span>feature-x-enabled<span style="color: #ff0000; font-weight: bold;">"</span><span style="color: #8b2252;">: true,</span>
<span style="color: #8b2252;">        "</span>value-of-y<span style="color: #ff0000; font-weight: bold;">"</span><span style="color: #8b2252;">: 1729,</span>
<span style="color: #8b2252;">        "</span>z-options<span style="color: #8b2252;">": {"</span>a<span style="color: #ff0000; font-weight: bold;">"</span><span style="color: #8b2252;">: null,</span>
<span style="color: #8b2252;">                      "</span>b<span style="color: #8b2252;">": "</span>220 <span style="color: #a020f0;">and</span> 284<span style="color: #ff0000; font-weight: bold;">"</span><span style="color: #8b2252;">,</span>
<span style="color: #8b2252;">                      "</span>c<span style="color: #ff0000; font-weight: bold;">"</span><span style="color: #8b2252;">: [6, 28, 496]}</span>
<span style="color: #8b2252;">       })"</span>_json;
<span style="color: #a020f0;">if</span> constexpr (jsv[<span style="color: #8b2252;">"feature-x-enabled"</span>]) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">code for feature x</span>
} <span style="color: #a020f0;">else</span> {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">code when feature x turned off</span>
}
</pre>
</div>

<aside class="notes">
<p>
When I first heard about <code>constexpr</code> I immediately thought of the potential for
this: generating compile-time data structures with UDLs. And JSON is an obvious
choice for a proof-of-concept.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgdb11e3b">
<h2 id="orgdb11e3b">The Promise of <code>constexpr</code></h2>
<ul>
<li>Runtime efficiency</li>
<li>Clearer code, fewer magic numbers</li>
<li>Less cross-platform pain</li>

</ul>

<aside class="notes">
<p>
Doing work at compile-time instead of runtime. Obvious gain.
</p>

<p>
Simplifying code through compile-time computation. No need for manual math,
preprocessor computation "to be sure", magic numbers.
</p>

<p>
Reducing steps in the toolchain. Don't maintain generation scripts: put it in
the C++.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgd62e779">
<h2 id="orgd62e779"><code>constexpr</code> History 101</h2>
<p>
A Short, Incomplete (and Mostly Wrong?) History of <code>constexpr</code>
</p>

</section>
<section id="slide-orgf6d2590">
<h3 id="orgf6d2590"><code>constexpr</code>: The First Age</h3>
<ul>
<li class="fragment appear">One (<code>return</code>) expression per function was allowed</li>
<li class="fragment appear"><code>constexpr</code> math functions explored</li>
<li class="fragment appear"><code>throw</code> link error trick discovered</li>
<li class="fragment appear">Recursive <code>constexpr</code> FNV1 string hash discovered</li>

</ul>

<aside class="notes">
<p>
C++11 constexpr was "extreme recursion" but many things were doable nonetheless.
</p>

<p>
Scott Schurr's talks at CppNow/CppCon hinted at things to come and expounded on
the throw trick for forcing compile-time evaluation.
</p>

</aside>

</section>
<section id="slide-org4846ced">
<h3 id="org4846ced"><code>constexpr</code>: End of the First Age</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">1. Fall of Gondolin</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">2. Balrogs destroyed</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">3. Morgoth defeated and cast into the Timeless Void</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">4. constexpr string hashing discovered</span>

constexpr <span style="color: #228b22;">uint64_t</span> <span style="color: #0000ff;">fnv1</span>(<span style="color: #228b22;">uint64_t</span> <span style="color: #a0522d;">h</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span>)
{
  <span style="color: #a020f0;">return</span> (*s == 0) ? h :
    fnv1((<span style="color: #228b22;">h</span> * 1099511628211ull) ^ <span style="color: #a020f0;">static_cast</span>&lt;uint64_t&gt;(*s), s+1);
}
</pre>
</div>

<aside class="notes">
<p>
At this point most people are probably familiar with this or something like it.
</p>

</aside>

</section>
<section id="slide-orgcd7c500">
<h3 id="orgcd7c500"><code>constexpr</code>: The Second Age</h3>
<ul>
<li class="fragment appear">Generalized <code>constexpr</code> supported by Visual C++</li>
<li class="fragment appear">Compile-time computation/optimization popularized by <a href="https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1"><i>C++ Weekly</i></a> et al.</li>
<li class="fragment appear">Generalized <code>constexpr</code> string hashing (e.g. Murmur3) discovered</li>
<li class="fragment appear"><code>constexpr</code> libraries start to appear</li>

</ul>

<aside class="notes">
<p>
For some reason, the major application of <code>constexpr</code> reported in the mainstream
seems to be string hashing.
</p>

</aside>

</section>
<section id="slide-org1f54e10">
<h3 id="org1f54e10"><code>constexpr</code>: End of the Second Age</h3>

<div class="figure">
<p><img src="./cpp14_murmur.png" alt="cpp14_murmur.png" />
</p>
</div>

<p>
(Also: Last Alliance of Elves &amp; Men, Isildur takes up the hilt of Narsil<br />
and cuts the One Ring from Sauron's hand.)
</p>

</section>
<section id="slide-orgf8ae7ec">
<h3 id="orgf8ae7ec"><code>constexpr</code>: The Third Age?</h3>
<ul>
<li class="fragment appear"><code>constexpr</code> lambdas</li>
<li class="fragment appear"><code>if constexpr</code></li>
<li class="fragment appear"><code>constexpr</code> STL proliferation?</li>
<li class="fragment appear">(coming soon, no doubt) <code>constexpr</code> cryptographic hashes</li>

</ul>

<aside class="notes">
<p>
<code>constexpr</code> lambdas are a really powerful thing (as we shall see).
</p>

<p>
<code>if constexpr</code> replaces many <code>std::enable_if</code> uses, more.
</p>

<p>
A selection of interesting <code>constexpr</code> things in the STL: <code>string_view</code>,
<code>array</code>, almost all of <code>chrono</code>.
</p>

<p>
New STL features are born with <code>constexpr</code> (somewhat) in mind: <code>optional</code>,
<code>variant</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf8f42cf">
<h2 id="orgf8f42cf">Building <code>constexpr</code> JSON Values</h2>
<p>
Two problems to solve:
</p>

<ol>
<li>How to represent JSON values</li>
<li>How to parse JSON values</li>

</ol>

</section>
</section>
<section>
<section id="slide-org5466652">
<h2 id="org5466652">Representing JSON Values</h2>
<p>
A JSON Value is a discriminated union of:<br />
<br />
</p>
<ul>
<li class="fragment appear">null</li>
<li class="fragment appear">boolean</li>
<li class="fragment appear">number</li>
<li class="fragment appear">string</li>
<li class="fragment appear">array of values</li>
<li class="fragment appear">object (map of string -&gt; value)</li>

</ul>

<p class="fragment (appear)">
<br />
Clearly this is going to need some sort of recursion. And we are going to need
<code>constexpr</code> ways to deal with a string, a vector and a map.
</p>

</section>
<section id="slide-orgf011c1f">
<h3 id="orgf011c1f"><code>constexpr</code> strings</h3>
<p>
<br />
First, <code>std::string_view</code> is great, and <i>mostly</i> <code>constexpr</code><br />
(depending on how up-to-date your library implementation is).<br />
<br />
<br />
Of course, <code>std::string_view</code> only really handles literal values:<br />
it doesn't deal with building strings, and is not intended for <i>storing</i> strings<br />
</p>

<aside class="notes">
<p>
<code>string_view</code> comparison is not yet <code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-orgb733b55">
<h3 id="orgb733b55"><code>constexpr</code> strings</h3>
<p>
<br />
We need a way to pass, store and in general work with<br />
character string literals.<br />
<br />
<br />
While <code>std::string_view</code> would technically work for this<br />
it kind of mixes-metaphors, since it is not intended for storing<br />
and comparison - just viewing.<br />
<br />
<br />
For this, we built up the <code>static_string</code> class
</p>

</section>
<section id="slide-orgc27b1ab">
<h3 id="orgc27b1ab"><code>constexpr</code> strings</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">static_string</span>
{
  <span style="color: #a020f0;">template</span> &lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span>&gt;
  <span style="color: #228b22;">constexpr</span> <span style="color: #0000ff;">static_string</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> (&amp;<span style="color: #a0522d;">str</span>)[N])
    : m_size(N-1), <span style="color: #228b22;">m_data</span>(&amp;<span style="color: #a0522d;">str</span>[0])
  {}

  <span style="color: #b22222;">// </span><span style="color: #b22222;">constructor for substrings of string literals</span>
  <span style="color: #228b22;">constexpr</span> <span style="color: #0000ff;">static_string</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">str</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">s</span>)
    : m_size(s), <span style="color: #228b22;">m_data</span>(<span style="color: #a0522d;">str</span>)
  {}

  <span style="color: #228b22;">constexpr</span> <span style="color: #0000ff;">static_string</span>() = <span style="color: #a020f0;">default</span>;

  <span style="color: #228b22;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">size</span>() <span style="color: #a020f0;">const</span> { <span style="color: #a020f0;">return</span> m_size; }
  <span style="color: #228b22;">constexpr</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *c_str() <span style="color: #a020f0;">const</span> { <span style="color: #a020f0;">return</span> m_data; }

  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span>{0};
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">m_data</span> = nullptr;
};
</pre>
</div>

</section>
<section id="slide-org795161e">
<h3 id="org795161e"><code>constexpr</code> vectors</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Value</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span> = 5&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">vector</span>
{
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">storage_t</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span>&lt;<span style="color: #228b22;">Value</span>, Size&gt;;
  <span style="color: #228b22;">storage_t</span> <span style="color: #a0522d;">m_data</span>{};
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span>{0};
  ...

  <span style="color: #b22222;">// </span><span style="color: #b22222;">iterators, push_back, operator[] etc</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">are pretty easy to write</span>
}
</pre>
</div>

<aside class="notes">
<p>
Obviously we need to know the max size at compile time.
</p>

</aside>

</section>
<section id="slide-org0008ab4">
<h3 id="org0008ab4"><code>constexpr</code> vectors</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">iterator</span> = <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">storage_t</span>::<span style="color: #228b22;">iterator</span>;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">const_iterator</span> = <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">storage_t</span>::<span style="color: #228b22;">const_iterator</span>;

<span style="color: #228b22;">constexpr</span> <span style="color: #a020f0;">auto</span> begin() <span style="color: #a020f0;">const</span> { <span style="color: #a020f0;">return</span> m_data.begin(); }
<span style="color: #228b22;">constexpr</span> <span style="color: #a020f0;">auto</span> end() <span style="color: #a020f0;">const</span> { <span style="color: #a020f0;">return</span> m_data.begin() + m_size; }
<span style="color: #b22222;">// </span><span style="color: #b22222;">and similarly for other iterator functions...</span>

<span style="color: #228b22;">constexpr</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span>(<span style="color: #228b22;">Value</span> <span style="color: #a0522d;">t_v</span>)
{
  <span style="color: #a020f0;">if</span> (m_size &gt;= Size) {
    <span style="color: #a020f0;">throw</span> <span style="color: #008b8b;">std</span>::range_error(<span style="color: #8b2252;">"Index past end of vector"</span>);
  } <span style="color: #a020f0;">else</span> {
    m_data[m_size++] = <span style="color: #008b8b;">std</span>::move(t_v);
  }
}
</pre>
</div>

<p>
We were not able to use <code>std::next()</code> here, seems to be a bug in the implementation&#x2026;
</p>

<aside class="notes">
<p>
Note that the <code>throw</code> here is a nicety: if we were to read/write past the end of
a <code>constexpr</code> array the compiler would give an error anyway. Assuming we are working
in a <code>constexpr</code> context. This throw protects us if this class is used just for a handy
statically sized vector.
</p>

</aside>

</section>
<section id="slide-org808c056">
<h3 id="org808c056"><code>constexpr</code> vectors</h3>
<p>
This allows for natural use of the <code>vector</code> type
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">vec</span>;
vec.push_back(15);
</pre>
</div>

</section>
<section id="slide-orga90a836">
<h3 id="orga90a836"><code>constexpr</code> vectors</h3>
<p>
Or put into a <code>constexpr</code> context
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">constexpr</span> <span style="color: #a020f0;">auto</span> get_vector() {
  <span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">vec</span>;
  vec.push_back(15);
  <span style="color: #a020f0;">return</span> vec;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #228b22;">constexpr</span> <span style="color: #a020f0;">auto</span> a_vector = get_vector();
  static_assert(a_vector.size() == 1);
}
</pre>
</div>


</section>
<section id="slide-org754a0af">
<h3 id="org754a0af">Some trivial issues that arise</h3>
<p>
In GCC's implementation: internal <code>__iterator_category</code> is not <code>constexpr</code> constructible.
</p>

<iframe width="1400px" height="800px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Carray%3E%0A%23include+%3Citerator%3E%0A%0Ausing+namespace+std%3B%0A%0Aconstexpr+array%3Cint,+5%3E+foo+%3D+%7B1,2,3,4,5%7D%3B%0A%0Aconstexpr+auto+third_of_foo()%0A%7B%0A++return+next(foo.cbegin(),+3)%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+i+%3D+*third_of_foo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.5479341055999998,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:21.627408993576015,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:78.37259100642399,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

</section>
<section id="slide-org47bcd0b">
<h3 id="org47bcd0b">mutable <code>constexpr</code> strings</h3>
<p>
And now we can build a mutable <code>constexpr</code> string by inheriting from our <code>vector</code>
</p>

</section>
<section id="slide-org701eb41">
<h3 id="org701eb41">mutable <code>constexpr</code> strings</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">CharType</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span>&gt;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">basic_string</span> : <span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">CharType</span>, Size&gt;
{
  <span style="color: #228b22;">constexpr</span> <span style="color: #0000ff;">basic_string</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">static_string</span> &amp;<span style="color: #a0522d;">s</span>) 
    : <span style="color: #228b22;">vector</span>&lt;CharType, Size&gt;(s.begin(), s.end())
  {
  }
  <span style="color: #228b22;">constexpr</span> <span style="color: #0000ff;">basic_string</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> &amp;<span style="color: #a0522d;">s</span>)
    : <span style="color: #228b22;">vector</span>&lt;CharType, Size&gt;(s.cbegin(), s.cend())
  {
  }
  <span style="color: #b22222;">// </span><span style="color: #b22222;">...</span>
};
</pre>
</div>

<p>
This relies on:<br />
</p>
<ul>
<li><code>constexpr</code> data members must be initialized, so our base vector is all <code>0</code></li>
<li>We have not provided any methods for shrinking our data structures, but that is possible</li>

</ul>



</section>
<section id="slide-org7f1298e">
<h3 id="org7f1298e"><code>constexpr</code> maps</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Key</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Value</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span> = 5&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">map</span>
{
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">storage_t</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span>&lt;<span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">pair</span>&lt;<span style="color: #228b22;">Key</span>, <span style="color: #228b22;">Value</span>&gt;, Size&gt;;
  <span style="color: #228b22;">storage_t</span> <span style="color: #a0522d;">m_data</span>{};
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span>{0};
  ...

  <span style="color: #b22222;">// </span><span style="color: #b22222;">iterators are the same as for arrays</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">operator[] needs a constexpr find</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">data grows in the same way that vector does</span>
}
</pre>
</div>

</section>
<section id="slide-org3bb77b6">
<h3 id="org3bb77b6"><code>constexpr</code> maps</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">get_colors</span>() {
  <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span>&lt;<span style="color: #008b8b;">cx</span>::static_string, <span style="color: #008b8b;">std</span>::uint32_t&gt; <span style="color: #a0522d;">colors</span>;
  colors[<span style="color: #8b2252;">"red"</span>] = 0xFF0000;
  colors[<span style="color: #8b2252;">"green"</span>] = 0x00FF00;
  <span style="color: #a020f0;">return</span> colors;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #228b22;">constexpr</span> <span style="color: #a0522d;">colors</span> = get_colors();
  colors[<span style="color: #8b2252;">"red"</span>]; <span style="color: #b22222;">// </span><span style="color: #b22222;">returns 0xFF0000</span>
  colors[<span style="color: #8b2252;">"blue"</span>]; <span style="color: #b22222;">// </span><span style="color: #b22222;">compile-time error</span>
}
</pre>
</div>

</section>
<section id="slide-org1690aaa">
<h3 id="org1690aaa">Why not <code>std::pair</code>?</h3>
<p>
Standard library definition does not have <code>constexpr operator=</code> <br />
for <code>std::pair</code><br />
<br />
This is the only aspect of <code>std::pair</code> that is not <code>constexpr</code>
</p>

<iframe width="1400px" height="800px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Cutility%3E%0A%0Ausing+namespace+std%3B%0A%0Astruct+P+%0A%7B%0A++std::pair%3Cconst+char*,+int%3E+pr%3B%0A%7D%3B%0A%0Aconstexpr+auto+pair_test()%0A%7B%0A++P+p%3B%0A++p.pr+%3D+make_pair(%22taxicab%22,+1729)%3B%0A++return+p%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+p+%3D+pair_test()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.2899450879999999,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:19.48608137044968,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:80.51391862955032,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

</section>
<section id="slide-org618d012">
<h3 id="org618d012"><code>constexpr find_if</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryPredicate</span>&gt;
constexpr <span style="color: #228b22;">InputIt</span> <span style="color: #0000ff;">find_if</span>(<span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">last</span>, <span style="color: #228b22;">UnaryPredicate</span> <span style="color: #a0522d;">p</span>)
{
  <span style="color: #a020f0;">for</span> (; first != last; ++first) {
    <span style="color: #a020f0;">if</span> (p(*first)) {
      <span style="color: #a020f0;">return</span> first;
    }
  }
  <span style="color: #a020f0;">return</span> last;
}
</pre>
</div>

<aside class="notes">
<p>
There's no technical reason for many algorithms not to be <code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-org3bc2098">
<h3 id="org3bc2098">Let's make them all <code>constexpr</code> already</h3>

<div class="figure">
<p><img src="./bryce_tweet.png" alt="bryce_tweet.png" />
</p>
</div>

</section>
<section id="slide-org9f5a2ac">
<h3 id="org9f5a2ac">Other algorithms we made <code>constexpr</code></h3>
<ul>
<li>mismatch</li>
<li>equal</li>
<li>copy</li>

</ul>

</section>
<section id="slide-org444e14d">
<h3 id="org444e14d">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span>=5&gt;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
{
  <span style="color: #a020f0;">static</span> constexpr <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_vector_size</span>{6};
  <span style="color: #a020f0;">static</span> constexpr <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_map_size</span>{6};

  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  {
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">boolean</span>{<span style="color: #008b8b;">false</span>};
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span>{0};
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span> <span style="color: #a0522d;">string</span>;
    <span style="color: #008b8b;">cx</span>::vector&lt;JSON_Value&lt;Depth-1&gt;, max_vector_size&gt; array;
    <span style="color: #008b8b;">cx</span>::map&lt;<span style="color: #008b8b;">cx</span>::static_string, JSON_Value&lt;Depth-1&gt;, max_map_size&gt; object;
  };
  <span style="color: #a020f0;">enum</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Type</span> { <span style="color: #a0522d;">Null</span>, <span style="color: #a0522d;">Boolean</span>, <span style="color: #a0522d;">Number</span>, <span style="color: #a0522d;">String</span>, <span style="color: #a0522d;">Array</span>, <span style="color: #a0522d;">Object</span> };

  <span style="color: #228b22;">Type</span> <span style="color: #a0522d;">type</span> = <span style="color: #008b8b;">Type</span>::Null;
  <span style="color: #228b22;">Data</span> <span style="color: #a0522d;">data</span>;
  ...
};

<span style="color: #a020f0;">template</span> &lt;&gt; <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>&lt;0&gt; {};
</pre>
</div>

<aside class="notes">
<p>
This makes for a lot of template instantiations, and has some obvious limitations.
</p>

<p>
The max sizes for arrays and objects are determined empirically.
</p>

</aside>

</section>
<section id="slide-org5dc1544">
<h3 id="org5dc1544">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
{
  constexpr <span style="color: #228b22;">void</span> <span style="color: #0000ff;">assert_type</span>(<span style="color: #228b22;">Type</span> <span style="color: #a0522d;">t</span>) <span style="color: #a020f0;">const</span>
  {
    <span style="color: #a020f0;">if</span> (type != t) <span style="color: #a020f0;">throw</span> <span style="color: #008b8b;">std</span>::runtime_error(<span style="color: #8b2252;">"Incorrect type"</span>);
  }

  <span style="color: #b22222;">// </span><span style="color: #b22222;">For Array, and similarly for the other types</span>
  <span style="color: #228b22;">constexpr</span> <span style="color: #0000ff;">decltype</span>(<span style="color: #a020f0;">auto</span>) to_Array() <span style="color: #a020f0;">const</span>
  {
    assert_type(<span style="color: #008b8b;">Type</span>::Array);
    <span style="color: #a020f0;">return</span> (data.array);
  }
  <span style="color: #228b22;">constexpr</span> <span style="color: #0000ff;">decltype</span>(<span style="color: #a020f0;">auto</span>) <span style="color: #0000ff;">to_Array</span>()
  {
    <span style="color: #a020f0;">if</span> (type != <span style="color: #008b8b;">Type</span>::Array) {
      type = <span style="color: #008b8b;">Type</span>::Array;
      data.array = {};
    }
    <span style="color: #a020f0;">return</span> (data.array);
  }
};
</pre>
</div>

</section>
<section id="slide-org3b74a7c">
<h3 id="org3b74a7c">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">JSON_Value</span> <span style="color: #a0522d;">j</span>{};
j[<span style="color: #8b2252;">"a"</span>].to_Number() = 15;
j[<span style="color: #8b2252;">"b"</span>].to_String() = <span style="color: #8b2252;">"Hello World"</span>;
j[<span style="color: #8b2252;">"d"</span>].to_Array();
j[<span style="color: #8b2252;">"c"</span>][<span style="color: #8b2252;">"a"</span>][<span style="color: #8b2252;">"b"</span>].to_Array().push_back(10.0);
j[<span style="color: #8b2252;">"c"</span>][<span style="color: #8b2252;">"a"</span>][<span style="color: #8b2252;">"c"</span>] = <span style="color: #008b8b;">cx</span>::static_string(<span style="color: #8b2252;">"Hello World"</span>);
j[<span style="color: #8b2252;">"c"</span>][<span style="color: #8b2252;">"a"</span>][<span style="color: #8b2252;">"d"</span>].to_Array().push_back(5.2);
</pre>
</div>

<aside class="notes">
<p>
But this kind of thing works. Note that we are using C++17 class template type
deduction here so we don't need to say <code>cx::JSON_Value&lt;&gt; j{};</code>
</p>

</aside>

</section>
<section id="slide-org5788d85">
<h3 id="org5788d85">Why not <code>std::variant</code> ?</h3>
<p>
Similarly to <code>std::pair</code>, <code>std::variant</code> is missing some key <code>constexpr</code> support.
</p>

<ul>
<li class="fragment appear"><code>std::variant(const std::variant &amp;)</code></li>
<li class="fragment appear"><code>std::variant(std::variant &amp;&amp;)</code></li>
<li class="fragment appear"><code>std::variant &amp;operator=(const std::variant &amp;)</code></li>
<li class="fragment appear"><code>std::variant &amp;operator=(std::variant &amp;&amp;)</code></li>

</ul>

</section>
<section id="slide-org42dfd43">
<h3 id="org42dfd43">Requirements for compile-time types</h3>
<p>
Huge list! Are you ready?! 
</p>

<ul>
<li class="fragment appear"><code>constexpr</code> constructor</li>
<li class="fragment appear"><code>std::is_trivially_destructible</code></li>

</ul>

<p class="fragment (appear)">
Nothing else is required if it does not get invoked.
</p>

</section>
<section id="slide-orga69d624">
<h3 id="orga69d624">STL shortcomings</h3>
<ul>
<li><code>array</code></li>
<li><code>string</code></li>
<li><code>string_view</code></li>
<li><code>pair</code></li>
<li><code>optional</code></li>
<li><code>variant</code></li>
<li><code>swap</code></li>

</ul>

</section>
<section id="slide-org00c9c1b">
<h3 id="org00c9c1b">Limitations of our containers</h3>
<ul>
<li>Fixed maximum size</li>
<li>(Currently) cannot shrink</li>
<li>Requires types that are default constructible</li>

</ul>

</section>
<section id="slide-orga9da71f">
<h3 id="orga9da71f">How to improve our containers</h3>
<ul>
<li>We could wrap objects in <code>std::optional</code> to allow for objects that are not defuault constructible</li>
<li>It should be possible to templatize on <code>constexpr</code> enabled allocator, making these containers optionally <code>constexpr</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org031b49b">
<h2 id="org031b49b">Parsing JSON Values Literals</h2>
<div class="outline-text-2" id="text-org031b49b">
</div></section>
<section id="slide-orgd3fcba6">
<h3 id="orgd3fcba6">Parsing</h3>
<br>

<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">::</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> [(a, <span style="color: #228b22;">String</span>)]
</pre>
</div>
<p>
"A parser for things is a function from strings to lists of pairs of things and strings."
</p>

<p>
&#x2013; <a href="http://www.willamette.edu/~fruehr/haskell/seuss.html">Dr Seuss on parsers</a>
</p>

<br><br>

<p>
Or in our case something like:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> &lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parser</span> = <span style="color: #a020f0;">auto</span> (*)(string) -&gt; list&lt;pair&lt;T, string&gt;&gt;;
</pre>
</div>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
