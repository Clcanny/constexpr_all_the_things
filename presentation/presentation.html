<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>constexpr ALL the things!</title>
<meta name="author" content="(Ben Deane & Jason Turner)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><img src="title.png"><h3>Ben Deane / <a href="mailto:bdeane@blizzard.com">bdeane@blizzard.com</a> / <a href="http://twitter.com/ben_deane">@ben_deane</a></h3><h3>Jason Turner / <a href="mailto:jason@emptycrate.com">jason@emptycrate.com</a> / <a href="http://twitter.com/lefticus">@lefticus</a></h3><h4>C++Now / Tuesday 16th May 2017</h4>
</section>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-org4eeb340">
<h2 id="org4eeb340">Don't Bury The Lede</h2>
<p>
We want to do this:
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsv
  = R<span style="color: #000000; background-color: #ffa500; font-weight: bold;">"</span><span style="color: #b22222;">({</span>
<span style="color: #b22222;">        "</span>feature-x-enabled<span style="color: #000000; background-color: #ffa500; font-weight: bold;">"</span><span style="color: #b22222;">: true,</span>
<span style="color: #b22222;">        "</span>value-of-y<span style="color: #000000; background-color: #ffa500; font-weight: bold;">"</span><span style="color: #b22222;">: 1729,</span>
<span style="color: #b22222;">        "</span>z-options<span style="color: #b22222;">": {"</span>a<span style="color: #000000; background-color: #ffa500; font-weight: bold;">"</span><span style="color: #b22222;">: null,</span>
<span style="color: #b22222;">                      "</span>b<span style="color: #b22222;">": "</span><span style="color: #008b8b;">220</span> <span style="color: #a020f0;">and</span> <span style="color: #008b8b;">284</span><span style="color: #000000; background-color: #ffa500; font-weight: bold;">"</span><span style="color: #b22222;">,</span>
<span style="color: #b22222;">                      "</span>c<span style="color: #000000; background-color: #ffa500; font-weight: bold;">"</span><span style="color: #b22222;">: [6, 28, 496]}</span>
<span style="color: #b22222;">       })"</span>_json;
<span style="color: #a020f0;">if</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #707183;">(</span>jsv<span style="color: #7388d6;">[</span><span style="color: #b22222;">"feature-x-enabled"</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">code for feature x</span>
<span style="color: #707183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #707183;">{</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">code when feature x turned off</span>
  <span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
When I first heard about <code>constexpr</code> I immediately thought of the potential for
this: generating compile-time data structures with UDLs. And JSON is an obvious
choice for a proof-of-concept.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf611bc7">
<h2 id="orgf611bc7">The Promise of <code>constexpr</code></h2>
<ul>
<li>Runtime efficiency</li>
<li>Clearer code, fewer magic numbers</li>
<li>Less cross-platform pain</li>

</ul>

<aside class="notes">
<p>
Jason talks about this.
</p>

<p>
Doing work at compile-time instead of runtime. Obvious gain.
</p>

<p>
Simplifying code through compile-time computation. No need for manual math,
preprocessor computation "to be sure", magic numbers.
</p>

<p>
Reducing steps in the toolchain. Don't maintain generation scripts: put it in
the C++.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgbaa4c8d">
<h2 id="orgbaa4c8d"><code>constexpr</code> History 101</h2>
<p>
A Short, Incomplete (and Mostly Wrong?) History of <code>constexpr</code>
</p>

<aside class="notes">
<p>
Ben to drive this section.
</p>

</aside>

</section>
<section id="slide-org2bc5f27">
<h3 id="org2bc5f27"><code>constexpr</code>: The First Age</h3>
<ul>
<li class="fragment appear">One (<code>return</code>) expression per function was allowed</li>
<li class="fragment appear"><code>constexpr</code> math functions explored</li>
<li class="fragment appear"><code>throw</code> link error trick discovered</li>
<li class="fragment appear">Recursive <code>constexpr</code> FNV1 string hash discovered</li>

</ul>

<aside class="notes">
<p>
C++11 constexpr was "extreme recursion" but many things were doable nonetheless.
</p>

<p>
Scott Schurr's talks at CppNow/CppCon hinted at things to come and expounded on
the throw trick for forcing compile-time evaluation.
</p>

</aside>

</section>
<section id="slide-org740c51b">
<h3 id="org740c51b"><code>constexpr</code>: End of the First Age</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">1. Fall of Gondolin</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">2. Balrogs destroyed</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">3. Morgoth defeated and cast into the Timeless Void</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">4. constexpr string hashing discovered</span>

<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">uint64_t</span> <span style="color: #0000ff;">fnv1</span><span style="color: #707183;">(</span><span style="color: #228b22;">uint64_t</span> <span style="color: #a0522d;">h</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span>*s == <span style="color: #008b8b;">0</span><span style="color: #7388d6;">)</span> ? h :
    fnv1<span style="color: #7388d6;">(</span><span style="color: #909183;">(</span><span style="color: #228b22;">h</span> * <span style="color: #008b8b;">1</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">099</span><span style="color: #008b8b;">511</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">628</span><span style="color: #008b8b;">211</span><span style="color: #008b8b;">ull</span><span style="color: #909183;">)</span> ^ <span style="color: #a020f0;">static_cast</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">uint64_t</span><span style="color: #909183;">&gt;(</span>*s<span style="color: #909183;">)</span>, s+<span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
At this point most people are probably familiar with this or something like it.
</p>

</aside>

</section>
<section id="slide-org0284887">
<h3 id="org0284887"><code>constexpr</code>: The Second Age</h3>
<ul>
<li class="fragment appear">Generalized <code>constexpr</code> supported by Visual C++</li>
<li class="fragment appear">Compile-time computation/optimization popularized by <a href="https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1"><i>C++ Weekly</i></a> et al.</li>
<li class="fragment appear">Generalized <code>constexpr</code> string hashing (e.g. Murmur3) discovered</li>
<li class="fragment appear"><code>constexpr</code> libraries start to appear</li>

</ul>

<aside class="notes">
<p>
For some reason, the major application of <code>constexpr</code> reported in the mainstream
seems to be string hashing.
</p>

</aside>

</section>
<section id="slide-orgba984cf">
<h3 id="orgba984cf"><code>constexpr</code>: End of the Second Age</h3>

<div class="figure">
<p><img src="./cpp14_murmur.png" alt="cpp14_murmur.png" />
</p>
</div>

<p>
(Also: Last Alliance of Elves &amp; Men, Isildur takes up the hilt of Narsil<br />
and cuts the One Ring from Sauron's hand.)
</p>

</section>
<section id="slide-org36f7fc0">
<h3 id="org36f7fc0"><code>constexpr</code>: The Third Age?</h3>
<ul>
<li class="fragment appear"><code>constexpr</code> lambdas</li>
<li class="fragment appear"><code>if constexpr</code></li>
<li class="fragment appear"><code>constexpr</code> STL proliferation?</li>
<li class="fragment appear">(coming soon, no doubt) <code>constexpr</code> cryptographic hashes</li>

</ul>

<aside class="notes">
<p>
<code>constexpr</code> lambdas are a really powerful thing (as we shall see).
</p>

<p>
<code>if constexpr</code> replaces many <code>std::enable_if</code> uses, more.
</p>

<p>
A selection of interesting <code>constexpr</code> things in the STL: <code>string_view</code>,
<code>array</code>, almost all of <code>chrono</code>.
</p>

<p>
New STL features are born with <code>constexpr</code> (somewhat) in mind: <code>optional</code>,
<code>variant</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc9a527d">
<h2 id="orgc9a527d">A problem with <code>constexpr</code></h2>

<div class="figure">
<p><img src="./constexpr_problem.png" alt="constexpr_problem.png" />
</p>
</div>

<p>
The inability to use different runtime and compile time algorithms.
</p>

</section>
<section id="slide-org66b5fd7">
<h3 id="org66b5fd7"><code>constexpr</code> SFINAE?</h3>
<p>
A partial solution, perhaps.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> str_view = <span style="color: #b22222;">"Computers are useless."</span>sv;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> cx_hash = fnv1<span style="color: #707183;">(</span>str_view<span style="color: #707183;">)</span>;

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">str</span> = <span style="color: #b22222;">"They can only give you answers."</span>s;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rt_hash</span> = fnv1<span style="color: #707183;">(</span>str<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
We would <i>like</i> the second call to <code>fnv1</code> to use an efficient runtime algorithm.
</p>

</section>
<section id="slide-orgbfe6701">
<h3 id="orgbfe6701"><code>constexpr</code> SFINAE?</h3>
<p>
You <i>can</i> do something like this&#x2026;
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">bool</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">true_t</span> = <span style="color: #008b8b;">std</span>::true_type;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> has_constexpr_default_constructor<span style="color: #707183;">(</span><span style="color: #228b22;">int</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">true_t</span><span style="color: #707183;">&lt;</span><span style="color: #7388d6;">(</span>T<span style="color: #909183;">{}</span>, <span style="color: #008b8b;">true</span><span style="color: #7388d6;">)</span><span style="color: #707183;">&gt;</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> has_constexpr_default_constructor<span style="color: #707183;">(</span>...<span style="color: #707183;">)</span> -&gt; <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">false_type</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">is_constexpr_default_constructible</span>
  : <span style="color: #a020f0;">decltype</span><span style="color: #707183;">(</span>has_constexpr_default_constructor<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;(</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">)</span><span style="color: #707183;">){}</span>;
</pre>
</div>

</section>
<section id="slide-org38822c5">
<h3 id="org38822c5"><code>constexpr</code> SFINAE?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">StringType</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">fnv1</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">StringType</span>&amp; <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #a020f0;">constexpr</span><span style="color: #7388d6;">(</span><span style="color: #008b8b;">is_constexpr_default_constructible</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">StringType</span><span style="color: #909183;">&gt;</span>::value<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">cx</span>::fnv1<span style="color: #909183;">(</span>s<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">runtime</span>::fnv1<span style="color: #909183;">(</span>s<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
Caveats: many.
</p>
<ul>
<li class="fragment appear">"<code>constexpr</code> constructible" doesn't mean "<code>constexpr</code> hashable"</li>
<li class="fragment appear">"<code>constexpr</code> capable" doesn't mean "in a <code>constexpr</code> context"</li>
<li class="fragment appear">verbosity, compile time?</li>

</ul>

<aside class="notes">
<p>
If you're going to go with this kind of thing, you might as well define
completely different types for use at compile time and runtime.
</p>

</aside>

</section>
<section id="slide-org884a244">
<h3 id="org884a244"><code>constexpr</code> SFINAE?</h3>
<p>
Another possible (better) solution.
</p>


<div class="figure">
<p><img src="./constexpr_operator.png" alt="constexpr_operator.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-org5e46883">
<h2 id="org5e46883">Building <code>constexpr</code> JSON Values</h2>
<p>
Two problems to solve:
</p>

<ol>
<li>How to represent JSON values</li>
<li>How to parse JSON values</li>

</ol>

</section>
</section>
<section>
<section id="slide-orga859a7c">
<h2 id="orga859a7c">Representing JSON Values</h2>
<p>
A JSON Value is a discriminated union of:<br />
<br />
</p>
<ul>
<li class="fragment appear">null</li>
<li class="fragment appear">boolean</li>
<li class="fragment appear">number</li>
<li class="fragment appear">string</li>
<li class="fragment appear">array of values</li>
<li class="fragment appear">object (map of string -&gt; value)</li>

</ul>

<p class="fragment (appear)">
<br />
Clearly this is going to need some sort of recursion. And we are going to need
<code>constexpr</code> ways to deal with a string, a vector and a map.
</p>

<aside class="notes">
<p>
Jason to drive this section.
</p>

</aside>

</section>
<section id="slide-org05e6d19">
<h3 id="org05e6d19"><code>constexpr</code> strings</h3>
<p>
<br />
First, <code>std::string_view</code> is great, and <i>mostly</i> <code>constexpr</code><br />
(depending on how up-to-date your library implementation is).<br />
<br />
<br />
Of course, <code>std::string_view</code> only really handles literal values:<br />
it doesn't deal with building strings, and is not intended for <i>storing</i> strings.
</p>

<aside class="notes">
<p>
<code>string_view</code> comparison is not yet <code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-orge724b36">
<h3 id="orge724b36"><code>constexpr</code> strings</h3>
<p>
<br />
We need a way to pass, store, and in general, work with<br />
character string literals.<br />
<br />
<br />
While <code>std::string_view</code> would technically work for this<br />
it kind of mixes metaphors, since it is not intended for storing<br />
and comparison - just viewing.<br />
<br />
<br />
For this, we built up the <code>static_string</code> class.
</p>

</section>
<section id="slide-org6eb2402">
<h3 id="org6eb2402"><code>constexpr</code> strings</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">static_string</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span><span style="color: #7388d6;">&gt;</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">static_string</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> <span style="color: #909183;">(</span>&amp;<span style="color: #a0522d;">str</span><span style="color: #909183;">)[</span>N<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>
    : m_size<span style="color: #7388d6;">(</span>N-<span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">m_data</span><span style="color: #7388d6;">(</span>&amp;str<span style="color: #909183;">[</span><span style="color: #008b8b;">0</span><span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">constructor for substrings of string literals</span>
  <span style="color: #a020f0;">constexpr</span> static_string<span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">str</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span>
    : m_size<span style="color: #7388d6;">(</span>s<span style="color: #7388d6;">)</span>, <span style="color: #228b22;">m_data</span><span style="color: #7388d6;">(</span><span style="color: #a0522d;">str</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>

  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">static_string</span><span style="color: #7388d6;">()</span> = <span style="color: #a020f0;">default</span>;

  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #0000ff;">size</span><span style="color: #7388d6;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> m_size; <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #0000ff;">c_str</span><span style="color: #7388d6;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span> <span style="color: #a020f0;">return</span> m_data; <span style="color: #7388d6;">}</span>

  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">m_data</span> = <span style="color: #008b8b;">nullptr</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orgcdbad1b">
<h3 id="orgcdbad1b"><code>constexpr</code> vectors</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Value</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span> = <span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">vector</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">storage_t</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Value</span>, Size<span style="color: #7388d6;">&gt;</span>;
  <span style="color: #228b22;">storage_t</span> <span style="color: #a0522d;">m_data</span><span style="color: #7388d6;">{}</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
  ...

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">iterators, push_back, operator[] etc</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">are pretty easy to write</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Obviously we need to know the max size at compile time.
</p>

</aside>

</section>
<section id="slide-orgbc39c53">
<h3 id="orgbc39c53"><code>constexpr</code> vectors</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">iterator</span> = <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">storage_t</span>::<span style="color: #228b22;">iterator</span>;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">const_iterator</span> = <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">storage_t</span>::<span style="color: #228b22;">const_iterator</span>;

<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">begin</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> m_data.begin<span style="color: #7388d6;">()</span>; <span style="color: #707183;">}</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">end</span><span style="color: #707183;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #707183;">{</span> <span style="color: #a020f0;">return</span> m_data.begin<span style="color: #7388d6;">()</span> + m_size; <span style="color: #707183;">}</span>
<span style="color: #bebebe;">// </span><span style="color: #bebebe;">and similarly for other iterator functions...</span>

<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #707183;">(</span><span style="color: #228b22;">Value</span> <span style="color: #a0522d;">t_v</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>m_size &gt;= Size<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">throw</span> <span style="color: #008b8b;">std</span>::range_error<span style="color: #909183;">(</span><span style="color: #b22222;">"Index past end of vector"</span><span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #7388d6;">{</span>
    m_data<span style="color: #909183;">[</span>m_size++<span style="color: #909183;">]</span> = <span style="color: #008b8b;">std</span>::move<span style="color: #909183;">(</span>t_v<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
We were not able to use <code>std::next()</code> here, seems to be a bug in the implementation&#x2026;
</p>

<aside class="notes">
<p>
Note that the <code>throw</code> here is a nicety: if we were to read/write past the end of
a <code>constexpr</code> array the compiler would give an error anyway. Assuming we are working
in a <code>constexpr</code> context. This throw protects us if this class is used just for a handy
statically sized vector.
</p>

</aside>


</section>
<section id="slide-org088edf0">
<h3 id="org088edf0">Why not <code>std::next</code>?</h3>
<p>
In GCC's implementation: internal <code>__iterator_category</code> is not <code>constexpr</code> constructible.
</p>

<iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Carray%3E%0A%23include+%3Citerator%3E%0A%0Ausing+namespace+std%3B%0A%0Aconstexpr+array%3Cint,+5%3E+foo+%3D+%7B1,2,3,4,5%7D%3B%0A%0Aconstexpr+auto+third_of_foo()%0A%7B%0A++return+next(foo.cbegin(),+3)%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+i+%3D+*third_of_foo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.5479341055999998,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:21.627408993576015,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:78.37259100642399,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

</section>
<section id="slide-orgc91dbc5">
<h3 id="orgc91dbc5"><code>constexpr</code> vectors</h3>
<p>
This allows for natural use of the <code>vector</code> type
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">vec</span>;
vec.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">15</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org12c9bdf">
<h3 id="org12c9bdf"><code>constexpr</code> vectors</h3>
<p>
Or put into a <code>constexpr</code> context
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">get_vector</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">vector</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">vec</span>;
  vec.push_back<span style="color: #7388d6;">(</span><span style="color: #008b8b;">15</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> vec;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> a_vector = get_vector<span style="color: #7388d6;">()</span>;
  static_assert<span style="color: #7388d6;">(</span>a_vector.size<span style="color: #909183;">()</span> == <span style="color: #008b8b;">1</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org17b3aa7">
<h3 id="org17b3aa7">mutable <code>constexpr</code> strings</h3>
<p>
And now we can build a mutable <code>constexpr</code> string by inheriting from our <code>vector</code>
</p>

</section>
<section id="slide-org12c6063">
<h3 id="org12c6063">mutable <code>constexpr</code> strings</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">CharType</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">basic_string</span> : <span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">CharType</span>, Size<span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">basic_string</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">static_string</span> &amp;<span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> 
    : vector<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">CharType</span>, Size<span style="color: #7388d6;">&gt;(</span>s.begin<span style="color: #909183;">()</span>, s.end<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>
  <span style="color: #a020f0;">constexpr</span> basic_string<span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> &amp;<span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span>
    : vector<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">CharType</span>, Size<span style="color: #7388d6;">&gt;(</span>s.cbegin<span style="color: #909183;">()</span>, s.cend<span style="color: #909183;">()</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">{}</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">...</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

<p>
This relies on:
</p>
<ul>
<li><code>constexpr</code> data members must be initialized, so our base vector is all <code>0</code></li>
<li>We have not provided any methods for shrinking our data structures, but that is possible</li>

</ul>

</section>
<section id="slide-orgb5a2503">
<h3 id="orgb5a2503"><code>constexpr</code> maps</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Key</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Value</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span> = <span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">map</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">storage_t</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">pair</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">Key</span>, <span style="color: #228b22;">Value</span><span style="color: #909183;">&gt;</span>, Size<span style="color: #7388d6;">&gt;</span>;
  <span style="color: #228b22;">storage_t</span> <span style="color: #a0522d;">m_data</span><span style="color: #7388d6;">{}</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">m_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">}</span>;
  ...

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">iterators are the same as for arrays</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">operator[] needs a constexpr find</span>
  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">data grows in the same way that vector does</span>
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orge675407">
<h3 id="orge675407"><code>constexpr</code> maps</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">get_colors</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">cx</span>::static_string, <span style="color: #008b8b;">std</span>::uint32_t<span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">colors</span>;
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #ffffff; background-color: #ff0000;">red</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">0x</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">FF</span><span style="color: #008b8b;">0000</span>;
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #000000; background-color: #00ff00;">green</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span> = <span style="color: #008b8b;">0x</span><span style="color: #008b8b; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">00</span><span style="color: #008b8b;">FF00</span>;
  <span style="color: #a020f0;">return</span> colors;
<span style="color: #707183;">}</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">colors</span> = get_colors<span style="color: #7388d6;">()</span>;
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #ffffff; background-color: #ff0000;">red</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span>; <span style="color: #bebebe;">// </span><span style="color: #bebebe;">returns 0x</span><span style="color: #bebebe; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">FF</span><span style="color: #bebebe;">0000</span>
  colors<span style="color: #7388d6;">[</span><span style="color: #b22222;">"</span><span style="color: #ffffff; background-color: #0000ff;">blue</span><span style="color: #b22222;">"</span><span style="color: #7388d6;">]</span>; <span style="color: #bebebe;">// </span><span style="color: #bebebe;">compile-time error</span>
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org4953d16">
<h3 id="org4953d16">Why not <code>std::pair</code>?</h3>
<p>
Standard library definition does not have <code>constexpr operator=</code> <br />
for <code>std::pair</code><br />
<br />
This is the only aspect of <code>std::pair</code> that is not <code>constexpr</code>
</p>

<iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Cutility%3E%0A%0Ausing+namespace+std%3B%0A%0Astruct+P+%0A%7B%0A++std::pair%3Cconst+char*,+int%3E+pr%3B%0A%7D%3B%0A%0Aconstexpr+auto+pair_test()%0A%7B%0A++P+p%3B%0A++p.pr+%3D+make_pair(%22taxicab%22,+1729)%3B%0A++return+p%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+p+%3D+pair_test()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.2899450879999999,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:19.48608137044968,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:80.51391862955032,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

</section>
<section id="slide-orgf25e112">
<h3 id="orgf25e112"><code>constexpr find_if</code></h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">InputIt</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">UnaryPredicate</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">InputIt</span> <span style="color: #0000ff;">find_if</span><span style="color: #707183;">(</span><span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">first</span>, <span style="color: #228b22;">InputIt</span> <span style="color: #a0522d;">last</span>, <span style="color: #228b22;">UnaryPredicate</span> <span style="color: #a0522d;">p</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">for</span> <span style="color: #7388d6;">(</span>; first != last; ++first<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>p<span style="color: #709870;">(</span>*first<span style="color: #709870;">)</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">return</span> first;
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">return</span> last;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
There's no technical reason for many algorithms not to be <code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-org19ae73c">
<h3 id="org19ae73c">Let's make them all <code>constexpr</code> already</h3>

<div class="figure">
<p><img src="./bryce_tweet.png" alt="bryce_tweet.png" />
</p>
</div>

</section>
<section id="slide-org872fb99">
<h3 id="org872fb99">Other algorithms we made <code>constexpr</code></h3>
<ul>
<li><code>mismatch</code></li>
<li><code>equal</code></li>
<li><code>copy</code></li>

</ul>

</section>
<section id="slide-org5367804">
<h3 id="org5367804">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span>=<span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_vector_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">6</span><span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_map_size</span><span style="color: #7388d6;">{</span><span style="color: #008b8b;">6</span><span style="color: #7388d6;">}</span>;

  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">boolean</span><span style="color: #909183;">{</span><span style="color: #008b8b;">false</span><span style="color: #909183;">}</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span><span style="color: #909183;">{</span><span style="color: #008b8b;">0</span><span style="color: #909183;">}</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span> <span style="color: #a0522d;">string</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span>, <span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">enum</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Type</span> <span style="color: #7388d6;">{</span> <span style="color: #a0522d;">Null</span>, <span style="color: #a0522d;">Boolean</span>, <span style="color: #a0522d;">Number</span>, <span style="color: #a0522d;">String</span>, <span style="color: #a0522d;">Array</span>, <span style="color: #a0522d;">Object</span> <span style="color: #7388d6;">}</span>;

  <span style="color: #228b22;">Type</span> <span style="color: #a0522d;">type</span> = <span style="color: #008b8b;">Type</span>::Null;
  <span style="color: #228b22;">Data</span> <span style="color: #a0522d;">data</span>;
  ...
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;&gt;</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">0</span><span style="color: #707183;">&gt;</span> <span style="color: #707183;">{}</span>;
</pre>
</div>

<aside class="notes">
<p>
This makes for a lot of template instantiations, and has some obvious limitations.
</p>

<p>
The max sizes for arrays and objects are determined empirically.
</p>

</aside>

</section>
<section id="slide-orgc68f61f">
<h3 id="orgc68f61f">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">assert_type</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">Type</span> <span style="color: #a0522d;">t</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">const</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>type != t<span style="color: #909183;">)</span> <span style="color: #a020f0;">throw</span> <span style="color: #008b8b;">std</span>::runtime_error<span style="color: #909183;">(</span><span style="color: #b22222;">"Incorrect type"</span><span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>

  <span style="color: #bebebe;">// </span><span style="color: #bebebe;">For Array, and similarly for the other types</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">decltype</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span><span style="color: #7388d6;">)</span> <span style="color: #0000ff;">to_Array</span><span style="color: #7388d6;">()</span> <span style="color: #a020f0;">const</span>
  <span style="color: #7388d6;">{</span>
    assert_type<span style="color: #909183;">(</span><span style="color: #008b8b;">Type</span>::Array<span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">return</span> <span style="color: #909183;">(</span>data.array<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">decltype</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">auto</span><span style="color: #7388d6;">)</span> <span style="color: #0000ff;">to_Array</span><span style="color: #7388d6;">()</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>type != <span style="color: #008b8b;">Type</span>::Array<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      type = <span style="color: #008b8b;">Type</span>::Array;
      data.array = <span style="color: #709870;">{}</span>;
    <span style="color: #909183;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #909183;">(</span>data.array<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org7f26701">
<h3 id="org7f26701">JSON Value: First attempt</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">JSON_Value</span> <span style="color: #a0522d;">j</span><span style="color: #707183;">{}</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">]</span>.to_Number<span style="color: #707183;">()</span> = <span style="color: #008b8b;">15</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"b"</span><span style="color: #707183;">]</span>.to_String<span style="color: #707183;">()</span> = <span style="color: #b22222;">"Hello World"</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"d"</span><span style="color: #707183;">]</span>.to_Array<span style="color: #707183;">()</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"b"</span><span style="color: #707183;">]</span>.to_Array<span style="color: #707183;">()</span>.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">10.0</span><span style="color: #707183;">)</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">]</span> = <span style="color: #008b8b;">cx</span>::static_string<span style="color: #707183;">(</span><span style="color: #b22222;">"Hello World"</span><span style="color: #707183;">)</span>;
j<span style="color: #707183;">[</span><span style="color: #b22222;">"c"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"a"</span><span style="color: #707183;">][</span><span style="color: #b22222;">"d"</span><span style="color: #707183;">]</span>.to_Array<span style="color: #707183;">()</span>.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">5.2</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
But this kind of thing works. Note that we are using C++17 class template type
deduction here so we don't need to say <code>cx::JSON_Value&lt;&gt; j{};</code>
</p>

</aside>

</section>
<section id="slide-orged08f26">
<h3 id="orged08f26">Why not <code>std::variant</code> ?</h3>
<p>
Similarly to <code>std::pair</code>, <code>std::variant</code> is missing some key <code>constexpr</code> support.
</p>

<ul>
<li class="fragment appear"><code>std::variant(const std::variant &amp;)</code></li>
<li class="fragment appear"><code>std::variant(std::variant &amp;&amp;)</code></li>
<li class="fragment appear"><code>std::variant &amp;operator=(const std::variant &amp;)</code></li>
<li class="fragment appear"><code>std::variant &amp;operator=(std::variant &amp;&amp;)</code></li>

</ul>

</section>
<section id="slide-org618256c">
<h3 id="org618256c">Requirements for compile-time types</h3>
<p>
Huge list! Are you ready?! 
</p>

<ul>
<li class="fragment appear"><code>constexpr</code> constructor</li>
<li class="fragment appear"><code>std::is_trivially_destructible</code></li>

</ul>

<p class="fragment (appear)">
Nothing else is required if it does not get invoked.
</p>

</section>
<section id="slide-orga01732c">
<h3 id="orga01732c">STL shortcomings</h3>
<ul>
<li><code>array</code></li>
<li><code>string</code></li>
<li><code>string_view</code></li>
<li><code>pair</code></li>
<li><code>optional</code></li>
<li><code>variant</code></li>
<li><code>swap</code></li>

</ul>

</section>
<section id="slide-org20bbb42">
<h3 id="org20bbb42">Limitations of our containers</h3>
<ul>
<li>Fixed maximum size</li>
<li>(Currently) cannot shrink</li>
<li>Requires types that are default constructible</li>

</ul>

</section>
<section id="slide-org3866d91">
<h3 id="org3866d91">How to improve our containers</h3>
<ul>
<li>We could wrap objects in <code>std::optional</code> to allow for objects that are not default constructible</li>
<li>It should be possible to templatize on <code>constexpr</code> enabled allocator, making these containers optionally <code>constexpr</code></li>

</ul>

</section>
<section id="slide-org391bc12">
<h3 id="org391bc12"><code>constexpr</code> allocator?</h3>
<p>
From cppreference.com
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">SimpleAllocator</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">T</span> <span style="color: #228b22;">value_type</span>;
  <span style="color: #0000ff;">SimpleAllocator</span><span style="color: #7388d6;">(</span><span style="color: #bebebe;">/*</span><span style="color: #bebebe;">ctor args*/</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span> <span style="color: #0000ff;">SimpleAllocator</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #909183;">&gt;</span>&amp; <span style="color: #a0522d;">other</span><span style="color: #7388d6;">)</span>;
  <span style="color: #228b22;">T</span>* <span style="color: #0000ff;">allocate</span><span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">deallocate</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">T</span>* <span style="color: #a0522d;">p</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>;
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>&amp;, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span>&amp;<span style="color: #707183;">)</span>;
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>&amp;, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">SimpleAllocator</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span>&amp;<span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org20785f2">
<h3 id="org20785f2"><code>constexpr</code> allocator?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">T</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Size</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">ConstexprAllocator</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">T</span> <span style="color: #228b22;">value_type</span>;
  <span style="color: #228b22;">consstexpr</span> <span style="color: #0000ff;">ConstexprAllocator</span><span style="color: #7388d6;">(</span><span style="color: #bebebe;">/*</span><span style="color: #bebebe;">ctor args*/</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">class</span> <span style="color: #228b22;">U</span><span style="color: #7388d6;">&gt;</span> 
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">ConstexprAllocator</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">ConstexprAllocator</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">U</span><span style="color: #909183;">&gt;</span>&amp; <span style="color: #a0522d;">other</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">T</span>* <span style="color: #0000ff;">allocate</span><span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">constexpr</span>  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">deallocate</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">T</span>* <span style="color: #a0522d;">p</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span><span style="color: #7388d6;">)</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">bool</span>, <span style="color: #228b22;">value_type</span><span style="color: #909183;">&gt;</span>, Size<span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">data</span>; <span style="color: #bebebe;">// </span><span style="color: #bebebe;">bool for free flag</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

<p>
Implementation left as an exercise to the reader.
</p>


</section>
</section>
<section>
<section id="slide-orga21ea52">
<h2 id="orga21ea52">Parsing JSON Value Literals</h2>
<p>
Because we need some way to actually turn a string literal into our JSON
representation.
</p>

<aside class="notes">
<p>
Ben drives this section.
</p>

</aside>

</section>
<section id="slide-org0aed4f5">
<h3 id="org0aed4f5">What is a Parser?</h3>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">::</span> <span style="color: #228b22;">String</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">[</span><span style="color: #7388d6;">(</span>a, <span style="color: #228b22;">String</span><span style="color: #7388d6;">)</span><span style="color: #707183;">]</span>
</pre>
</div>
<p>
"A parser for things is a function from strings to lists of pairs of things and strings."
</p>

<p>
&#x2013; <a href="http://www.willamette.edu/~fruehr/haskell/seuss.html">Dr Seuss on parsers</a><br />
<br />
<br />
Or in our case something like:
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parser</span> = <span style="color: #a020f0;">auto</span> <span style="color: #707183;">(</span>*<span style="color: #707183;">)(</span>string<span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">list</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span>, <span style="color: #228b22;">string</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<aside class="notes">
<p>
This serendipitous phrase is due to Fritz Ruehr, a functional programming
lecturer at Willamette University.
</p>

</aside>

</section>
<section id="slide-org9dddf15">
<h3 id="org9dddf15">Parsers</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parser</span> = <span style="color: #a020f0;">auto</span> <span style="color: #707183;">(</span>*<span style="color: #707183;">)(</span>string<span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">list</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span>, <span style="color: #228b22;">string</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
Of course, we don't really mean quite this&#x2026;
</p>

<ul>
<li class="fragment appear"><code>string</code> -&gt; <code>string_view</code> (compile-time stringlike thing)</li>
<li class="fragment appear"><code>list</code> -&gt; <code>optional</code> (simpler)</li>
<li class="fragment appear">"function" -&gt; "something invocable"</li>

</ul>

<aside class="notes">
<p>
Strings are any stringlike thing - <code>string_view</code> will do nicely since we're just
reading this from a literal. The input is obvious, the output is the leftover
part of the string after parsing a T.
</p>

<p>
List represents optionality - a given string might have several ways it can be
parsed. For simplicity we can just assume one way or error, i.e. optional.
</p>

<p>
Of course we'll use the <code>constexpr</code> friendly <code>pair</code>.
</p>

<p>
And when we say "function" we mean the usual invocable things. Including <code>constexpr</code>
lambdas!
</p>

</aside>

</section>
<section id="slide-orgc200bcb">
<h3 id="orgc200bcb">A Simple Parser</h3>
<p>
Let's have a couple of aliases that will make life simpler.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">parse_input_t</span> = <span style="color: #008b8b;">std</span>::string_view;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parse_result_t</span> = <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">optional</span><span style="color: #707183;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">pair</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span>, <span style="color: #228b22;">parse_input_t</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
And let's make a parser that matches a single <code>char</code> that we give it.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">match_char</span><span style="color: #707183;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #707183;">&gt;</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>s.empty<span style="color: #909183;">()</span> || s<span style="color: #909183;">[</span><span style="color: #008b8b;">0</span><span style="color: #909183;">]</span> != c<span style="color: #7388d6;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
  <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;(</span>
    <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #909183;">(</span>c, parse_input_t<span style="color: #709870;">(</span>s.data<span style="color: #907373;">()</span>+<span style="color: #008b8b;">1</span>, s.size<span style="color: #907373;">()</span>-<span style="color: #008b8b;">1</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is what a parser does: either matches or not (hence the optional) and if it
matches, returns the value matched and the rest of the string for use in future
parsers.
</p>

</aside>

</section>
<section id="slide-org44b7e5e">
<h3 id="org44b7e5e">A Simple Parser</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">Ceci n'est pas une parser.</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">match_char</span><span style="color: #707183;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
<code>match_char</code> isn't actually a parser, because it has the wrong signature.<br />
<br />
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">This is the signature of a parser.</span>
<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">parser</span> = <span style="color: #a020f0;">auto</span> <span style="color: #707183;">(</span>*<span style="color: #707183;">)(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #707183;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>;
</pre>
</div>

<p>
But now that we have <code>constexpr</code> lambdas, we can write a function that returns a
parser.
</p>

</section>
<section id="slide-org9b67c74">
<h3 id="org9b67c74">A Simple Parser</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_char_parser</span><span style="color: #707183;">(</span><span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>s.empty<span style="color: #709870;">()</span> || s<span style="color: #709870;">[</span><span style="color: #008b8b;">0</span><span style="color: #709870;">]</span> != c<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
    <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #909183;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #909183;">&gt;(</span>
        <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #709870;">(</span>c, parse_input_t<span style="color: #907373;">(</span>s.data<span style="color: #6276ba;">()</span>+<span style="color: #008b8b;">1</span>, s.size<span style="color: #6276ba;">()</span>-<span style="color: #008b8b;">1</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
The lambda returned from <code>make_char_parser</code> is a parser that will match the
given <code>char</code>.
</p>

</section>
<section id="slide-org3b39e98">
<h3 id="org3b39e98">More useful primitive parsers</h3>
<p>
So far we can match one <code>char</code>. Because fundamentally parsing works on
"strings", there are a couple of other parsers that will be useful.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">parse one of a set of chars</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">one_of</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">chars</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>s.empty<span style="color: #709870;">()</span><span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">basic_string_view::find is supposed to be constexpr, but no...</span>
    <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">j</span> = <span style="color: #008b8b;">cx</span>::find<span style="color: #909183;">(</span>chars.cbegin<span style="color: #709870;">()</span>, chars.cend<span style="color: #709870;">()</span>, s<span style="color: #709870;">[</span><span style="color: #008b8b;">0</span><span style="color: #709870;">]</span><span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>j != chars.cend<span style="color: #709870;">()</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #709870;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #709870;">&gt;(</span>
          <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #907373;">(</span>s<span style="color: #6276ba;">[</span><span style="color: #008b8b;">0</span><span style="color: #6276ba;">]</span>, parse_input_t<span style="color: #6276ba;">(</span>s.data<span style="color: #858580;">()</span>+<span style="color: #008b8b;">1</span>, s.size<span style="color: #858580;">()</span>-<span style="color: #008b8b;">1</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>;
    <span style="color: #909183;">}</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-org4ccaa69">
<h3 id="org4ccaa69">More useful primitive parsers</h3>
<p>
And you can imagine how to write these.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #bebebe;">// </span><span style="color: #bebebe;">the opposite of one_of: match a char that isn't any of the given set</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">none_of</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">chars</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    ...
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>

<span style="color: #bebebe;">// </span><span style="color: #bebebe;">match a given string</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">make_string_parser</span><span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span> <span style="color: #a0522d;">str</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string_view</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">here we could use a constexpr version of std::mismatch...</span>
    ...
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orgf59b5f0">
<h3 id="orgf59b5f0">Building up</h3>
<p>
<br />
So far we have a few primitive parsers.<br />
<br />
<br />
In order to simply build up more complex parsers, we need to be able to<br />
<b>combine</b> parsers in various ways.
</p>

</section>
<section id="slide-org00e68c2">
<h3 id="org00e68c2">Building up</h3>
<p>
Some basic things we will want to do:
</p>

<ul>
<li>Change the result type of a parser (<code>fmap</code>)</li>
<li>Run one parser, then a second one based on what the first returned (<code>bind</code>)</li>
<li>Run one parser, and if it fails run another (<code>operator|</code>)</li>
<li>Run two parsers in succession and combine the outputs (<code>combine</code>)</li>

</ul>

<p>
(Pick your functional pattern: functor, monad, monoid, applicative&#x2026;)
</p>

<aside class="notes">
<p>
Some suggested names for the operations involved.
</p>

<p>
"Change the result type" = run a function on the result to turn it into something else.
</p>

<p>
<code>operator|</code> is the monoid operation (with the parser that always fails as the unit).
</p>

<p>
<code>combine</code> is the applicative operation.
</p>

<p>
I'll show you a few of these combinators so you can get a feel for them.
</p>

</aside>

</section>
<section id="slide-org01b96bc">
<h3 id="org01b96bc">Changing the result type (<code>fmap</code>)</h3>
<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #0000ff;">fmap</span> <span style="color: #a0522d;">::</span> <span style="color: #707183;">(</span>a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">fmap</span><span style="color: #707183;">(</span><span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span>, <span style="color: #228b22;">P</span>&amp;&amp; <span style="color: #a0522d;">p</span><span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">R</span> = <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">result_of_t</span><span style="color: #909183;">&lt;</span><span style="color: #0000ff;">F</span><span style="color: #709870;">(</span><span style="color: #228b22;">parse_t</span><span style="color: #907373;">&lt;</span><span style="color: #228b22;">P</span><span style="color: #907373;">&gt;</span><span style="color: #709870;">)</span><span style="color: #909183;">&gt;</span><span style="color: #7388d6;">&gt;</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>f = <span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">F</span><span style="color: #909183;">&gt;(</span>f<span style="color: #909183;">)</span>,
          p = <span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">P</span><span style="color: #909183;">&gt;(</span>p<span style="color: #909183;">)</span><span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> -&gt; R <span style="color: #7388d6;">{</span>
           <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r = p<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
           <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>!r<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
           <span style="color: #a020f0;">return</span> R<span style="color: #909183;">(</span><span style="color: #008b8b;">cx</span>::make_pair<span style="color: #709870;">(</span>f<span style="color: #907373;">(</span>r-&gt;first<span style="color: #907373;">)</span>, r-&gt;second<span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
         <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
<code>parse_t</code> here is just a way of getting the parsed type back out of the parser
without all the optional/pair business.
</p>

<p>
Note what fmap returns is a parser.
</p>

<p>
Think about a simple case of turning a char into an int.
</p>

</aside>

</section>
<section id="slide-orgeb9903a">
<h3 id="orgeb9903a">Alternation (<code>operator|</code>)</h3>
<div class="org-src-container">

<pre  class="src src-haskell">operator<span style="color: #0000ff;">|</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P2</span>,
          <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">enable_if_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_same_v</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #709870;">&gt;</span>, <span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #709870;">&gt;</span><span style="color: #909183;">&gt;</span>, <span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span> = <span style="color: #008b8b;">0</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">|</span><span style="color: #707183;">(</span>P1&amp;&amp; p1, P2&amp;&amp; p2<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r1 = p1<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>r1<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> r1;
    <span style="color: #a020f0;">return</span> p2<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">fail</span><span style="color: #707183;">(</span><span style="color: #228b22;">T</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span>parse_input_t<span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
  <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Alternation is the monoid operation. <code>fail</code> is the identity.
</p>

</aside>

</section>
<section id="slide-org30f7224">
<h3 id="org30f7224">Conjunction (<code>combine</code>)</h3>
<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #0000ff;">combine</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>a <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> c<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> c
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P2</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">F</span>,
          <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">R</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">result_of_t</span><span style="color: #7388d6;">&lt;</span>F<span style="color: #909183;">(</span><span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #709870;">&gt;</span>, <span style="color: #228b22;">parse_t</span><span style="color: #709870;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #709870;">&gt;</span><span style="color: #909183;">)</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">combine</span><span style="color: #707183;">(</span><span style="color: #228b22;">P1</span>&amp;&amp; <span style="color: #a0522d;">p1</span>, <span style="color: #228b22;">P2</span>&amp;&amp; <span style="color: #a0522d;">p2</span>, <span style="color: #228b22;">F</span>&amp;&amp; <span style="color: #a0522d;">f</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">[</span>=<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> -&gt; <span style="color: #228b22;">parse_result_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">R</span><span style="color: #7388d6;">&gt;</span> <span style="color: #7388d6;">{</span>
           <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r1 = p1<span style="color: #909183;">(</span>i<span style="color: #909183;">)</span>;
           <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>!r1<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
           <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> r2 = p2<span style="color: #909183;">(</span>r1-&gt;second<span style="color: #909183;">)</span>;
           <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>!r2<span style="color: #909183;">)</span> <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::nullopt;
           <span style="color: #a020f0;">return</span> parse_result_t<span style="color: #909183;">&lt;</span><span style="color: #228b22;">R</span><span style="color: #909183;">&gt;(</span>
               <span style="color: #008b8b;">cx</span>::make_pair<span style="color: #709870;">(</span>f<span style="color: #907373;">(</span>r1-&gt;first, r2-&gt;first<span style="color: #907373;">)</span>, r2-&gt;second<span style="color: #709870;">)</span><span style="color: #909183;">)</span>;
         <span style="color: #7388d6;">}</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
<code>combine</code> is a bit like <code>fmap</code> for multiple-argument functions. In some sense
the applicative operation.
</p>

<p>
Note that both parsers need to succeed, and we run the second parser on what is
leftover from the first, then return what is leftover from the second.
</p>

</aside>

</section>
<section id="slide-org53f5269">
<h3 id="org53f5269">Useful <code>combine</code> patterns</h3>
<div class="org-src-container">

<pre  class="src src-haskell">operator<span style="color: #0000ff;">&gt;</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> a
operator<span style="color: #0000ff;">&lt;</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P1</span>, <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">P2</span>,
          <span style="color: #a020f0;">typename</span> = <span style="color: #228b22;">parse_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #7388d6;">&gt;</span>, <span style="color: #a020f0;">typename</span> = <span style="color: #228b22;">parse_t</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span><span style="color: #707183;">(</span>P1&amp;&amp; p1, P2&amp;&amp; p2<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> combine<span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">P1</span><span style="color: #909183;">&gt;(</span>p1<span style="color: #909183;">)</span>,
                 <span style="color: #008b8b;">std</span>::forward<span style="color: #909183;">&lt;</span><span style="color: #228b22;">P2</span><span style="color: #909183;">&gt;(</span>p2<span style="color: #909183;">)</span>,
                 <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">auto</span>, <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span>&amp; <span style="color: #a0522d;">r</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span> <span style="color: #a020f0;">return</span> r; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
These operators are useful for throwing away the left or right hand side of <code>combine</code>.
</p>

<aside class="notes">
<p>
These simple formulations of combine are very useful. They allow us to run
multiple parsers in succession, keeping just the left hand side or the right
hand side.
</p>

<p>
And of course the operators are symmetric and left-associative.
</p>

</aside>

</section>
<section id="slide-orgfb2cb15">
<h3 id="orgfb2cb15">Accumulating combinators</h3>
<p>
And now you begin to see where this is heading&#x2026;
</p>

<div class="org-src-container">

<pre  class="src src-haskell"><span style="color: #0000ff;">many</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span>  <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
<span style="color: #0000ff;">many1</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span>  <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
<span style="color: #0000ff;">exactly_n</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> int <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
<span style="color: #0000ff;">separated_by</span> <span style="color: #a0522d;">::</span> <span style="color: #228b22;">Parser</span> a <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> x <span style="color: #a0522d;">-&gt;</span> b <span style="color: #a0522d;">-&gt;</span> <span style="color: #707183;">(</span>b <span style="color: #a0522d;">-&gt;</span> a <span style="color: #a0522d;">-&gt;</span> b<span style="color: #707183;">)</span> <span style="color: #a0522d;">-&gt;</span> <span style="color: #228b22;">Parser</span> b
</pre>
</div>

<p>
These are starting to look like building blocks we can use to parse real things.
</p>

<aside class="notes">
<p>
Explain each of these function signatures.
</p>

</aside>

</section>
<section id="slide-org7719f78">
<h3 id="org7719f78">Some simple examples</h3>
<p>
This parser eats whitespace.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">skip_whitespace</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> ws_parser =
    make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">' '</span><span style="color: #7388d6;">)</span>
    | make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">t</span><span style="color: #b22222;">'</span><span style="color: #7388d6;">)</span>
    | make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">n</span><span style="color: #b22222;">'</span><span style="color: #7388d6;">)</span>
    | make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">r</span><span style="color: #b22222;">'</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> many<span style="color: #7388d6;">(</span>ws_parser, <span style="color: #008b8b;">std</span>::monostate<span style="color: #909183;">{}</span>, <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">m</span>, <span style="color: #a020f0;">auto</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span> <span style="color: #a020f0;">return</span> m; <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Alternation of each individual parser.
</p>

<p>
Then many (zero or more) of the resulting parser.
</p>

<p>
The key to all the combinators is that what they return are themselves parsers.
Composition!
</p>

</aside>

</section>
<section id="slide-orgf77a4c6">
<h3 id="orgf77a4c6">Some simple examples</h3>
<p>
This parses a decimal integer.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">int_parser</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> bind<span style="color: #7388d6;">(</span>one_of<span style="color: #909183;">(</span><span style="color: #b22222;">"</span><span style="color: #b22222;">123</span><span style="color: #b22222; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">456</span><span style="color: #b22222;">789</span><span style="color: #b22222;">"</span>sv<span style="color: #909183;">)</span>,
              <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #228b22;">char</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">rest</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
                <span style="color: #a020f0;">return</span> many<span style="color: #709870;">(</span>one_of<span style="color: #907373;">(</span><span style="color: #b22222;">"</span><span style="color: #b22222; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">0</span><span style="color: #b22222;">123</span><span style="color: #b22222; background-color: #eeeeee; font-weight: bold; text-decoration: underline;">456</span><span style="color: #b22222;">789</span><span style="color: #b22222;">"</span>sv<span style="color: #907373;">)</span>,
                            <span style="color: #a020f0;">static_cast</span><span style="color: #907373;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #907373;">&gt;(</span>x - <span style="color: #b22222;">'0'</span><span style="color: #907373;">)</span>,
                            <span style="color: #907373;">[]</span> <span style="color: #907373;">(</span><span style="color: #228b22;">int</span> <span style="color: #a0522d;">acc</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">c</span><span style="color: #907373;">)</span> <span style="color: #907373;">{</span> <span style="color: #a020f0;">return</span> <span style="color: #6276ba;">(</span><span style="color: #228b22;">acc</span>*<span style="color: #008b8b;">10</span><span style="color: #6276ba;">)</span> + <span style="color: #6276ba;">(</span>c-<span style="color: #b22222;">'0'</span><span style="color: #6276ba;">)</span>; <span style="color: #907373;">}</span><span style="color: #709870;">)(</span>rest<span style="color: #709870;">)</span>;
              <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
First any non-zero digit, then zero or more digits,<br />
building up the integer in the obvious way.
</p>

<aside class="notes">
<p>
Note that <code>bind</code>'s second argument carries the leftover string through as well
as the parse result of the first argument.
</p>

</aside>

</section>
<section id="slide-orgf1b32fb">
<h3 id="orgf1b32fb">Some simple examples</h3>
<p>
This (very simply) parses a string.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">string_parser</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> quote_parser = make_char_parser<span style="color: #7388d6;">(</span><span style="color: #b22222;">'"'</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> str_parser =
    many<span style="color: #7388d6;">(</span>none_of<span style="color: #909183;">(</span><span style="color: #b22222;">"</span><span style="color: #b22222; font-weight: bold;">\</span><span style="color: #b22222; font-weight: bold;">"</span><span style="color: #b22222;">"</span>sv<span style="color: #909183;">)</span>,
         <span style="color: #008b8b;">std</span>::string_view<span style="color: #909183;">(</span>s.data<span style="color: #709870;">()</span>+<span style="color: #008b8b;">1</span>, <span style="color: #008b8b;">0</span><span style="color: #909183;">)</span>,
         <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span>&amp; <span style="color: #a0522d;">acc</span>, <span style="color: #a020f0;">auto</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
           <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">(</span>acc.data<span style="color: #907373;">()</span>, acc.size<span style="color: #907373;">()</span>+<span style="color: #008b8b;">1</span><span style="color: #709870;">)</span>;
         <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #228b22;">quote_parser</span> <span style="color: #7388d6;">&lt;</span> str_parser <span style="color: #7388d6;">&gt;</span> quote_parser;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
For the sake of simplicity, we aren't dealing with escaped characters, unicode
points, etc.
</p>

<p>
In fact for this simple example we are accumulating a <code>string_view</code>. But in
general when we come to parse escaped characters, the input characters don't
have a 1-to-1 mapping with the output characters.
</p>

</aside>

</section>
<section id="slide-org6c1966d">
<h3 id="org6c1966d">Getting to JSON</h3>
<p>
We now have a toolkit for building parsers.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span>=<span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  ...
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">boolean</span><span style="color: #909183;">{</span><span style="color: #008b8b;">false</span><span style="color: #909183;">}</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span><span style="color: #909183;">{</span><span style="color: #008b8b;">0</span><span style="color: #909183;">}</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span> <span style="color: #a0522d;">string</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">static_string</span>, <span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>
<p>
To parse our JSON value, a reasonable approach is to use<br />
alternation on parsers for each type of value.
</p>

<aside class="notes">
<p>
We're going to have 6 different parsers, each of which produces a <code>JSON_Value</code>,
and we're going to alternate them together.
</p>

<p>
They will be mutually recursive: the parsers for objects and arrays call the
value parsers.
</p>

<p>
In order to achieve mutual recursion, we'll put them in a struct. (The next
couple of slides contain a lot of code - sorry.)
</p>

</aside>

</section>
<section id="slide-orgd017c46">
<h3 id="orgd017c46">Recursive parsing structure</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">recur</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #7388d6;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">value_parser</span><span style="color: #7388d6;">()</span>
  <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> p =
      fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span><span style="color: #008b8b;">std</span>::monostate<span style="color: #6276ba;">{}</span><span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
           make_string_parser<span style="color: #709870;">(</span><span style="color: #b22222;">"null"</span>sv<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span><span style="color: #008b8b;">true</span><span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             make_string_parser<span style="color: #709870;">(</span><span style="color: #b22222;">"true"</span>sv<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span><span style="color: #008b8b;">false</span><span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             make_string_parser<span style="color: #709870;">(</span><span style="color: #b22222;">"false"</span>sv<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">n</span><span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span>n<span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             number_parser<span style="color: #709870;">()</span><span style="color: #909183;">)</span>
      | fmap<span style="color: #909183;">(</span><span style="color: #709870;">[]</span> <span style="color: #709870;">(</span><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">str</span><span style="color: #709870;">)</span> <span style="color: #709870;">{</span> <span style="color: #a020f0;">return</span> JSON_Value<span style="color: #907373;">&lt;</span>Depth<span style="color: #907373;">&gt;(</span>str<span style="color: #907373;">)</span>; <span style="color: #709870;">}</span>,
             string_parser<span style="color: #709870;">()</span><span style="color: #909183;">)</span>
      | array_parser<span style="color: #909183;">&lt;</span>Depth<span style="color: #909183;">&gt;()</span>
      | object_parser<span style="color: #909183;">&lt;</span>Depth<span style="color: #909183;">&gt;()</span>;
    <span style="color: #a020f0;">return</span> skip_whitespace<span style="color: #909183;">()</span> &lt; p;
  <span style="color: #7388d6;">}</span>
  ...
</pre>
</div>

<aside class="notes">
<p>
<code>value_parser</code> is the top level entry point to our parser.
</p>

<p>
Each argument of alternation must return the same type: in this case, they are
<code>JSON_Value</code> parsers, obtained from each other parse type by fmapping in an
appropriate function.
</p>

<p>
Note the way we eat whitespace before a value. Easy with the applicative
operator. It would be "easy" to sprinkle <code>skip_whitespace()</code> everywhere and it
would work&#x2026; but a more disciplined approach is to eating whitespace <b>before</b>
the parses that need it.
</p>

</aside>

</section>
<section id="slide-orgf789dc3">
<h3 id="orgf789dc3">Recursive parsing structure</h3>
<div class="org-src-container">

<pre  class="src src-c++">  ...
  <span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #707183;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> array_parser<span style="color: #707183;">()</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>

  <span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #707183;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">key_value_parser</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>

  <span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span> = max_parse_depth<span style="color: #707183;">&gt;</span>
  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">object_parser</span><span style="color: #707183;">()</span> <span style="color: #707183;">{</span> ... <span style="color: #707183;">}</span>
<span style="color: #88090B;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #88090B;">&lt;&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #008b8b;">recur</span>::<span style="color: #0000ff;">value_parser</span><span style="color: #88090B;">&lt;</span><span style="color: #008b8b;">0</span><span style="color: #88090B;">&gt;()</span> <span style="color: #88090B;">{</span>
  <span style="color: #a020f0;">return</span> fail<span style="color: #707183;">(</span><span style="color: #228b22;">JSON_Value</span><span style="color: #7388d6;">&lt;</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">&gt;{}</span><span style="color: #707183;">)</span>;
<span style="color: #88090B;">}</span>

<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span> <span style="color: #b22222;">""</span> _json<span style="color: #88090B;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">str</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span><span style="color: #88090B;">)</span> <span style="color: #88090B;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">recur</span>::value_parser<span style="color: #707183;">&lt;&gt;()(</span><span style="color: #008b8b;">std</span>::string_view<span style="color: #7388d6;">{</span>str, len<span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
<span style="color: #88090B;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The body of everything is too much code to show, but you can imagine how these
work.
</p>

<p>
For <code>array_parser</code>, we parse an open square bracket, then we use our
<code>separated_by</code> combinator to parse values separated by commas, then we parse a
closing square bracket. The JSON value we return is an array type value which
has had its array member accumulated with the comma-separated values we parsed.
</p>

<p>
Object parser is similar, but open/close curly braces, and key-value pairs
separated by commas. A key-value pair is itself a string followed by a colon
followed by a value.
</p>

<p>
Each time we recurse through <code>value_parser</code>, we decrement the <code>Depth</code>
template value to produce the next level of the JSON tree.
</p>

<p>
Note the use of <code>fail</code>: an easy way to provide the right type for the base case.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgee8d623">
<h2 id="orgee8d623">Parsing JSON Value Literals (Better)</h2>
<p>
<br />
What we have so far is the simplest proof-of-concept.<br />
<br />
<br />
It works (for suitable values of "works").<br />
<br />
<br />
It's a good starting point, but there are a few problems we need to address.
</p>

<aside class="notes">
<p>
What we have so far is a good starting point. The parsing toolkit is pretty useful.
</p>

</aside>

</section>
<section id="slide-orgbce8181">
<h3 id="orgbce8181">Problem 1: A JSON number isn't an <code>int</code></h3>

<div class="figure">
<p><img src="./json_number.png" alt="json_number.png" />
</p>
</div>

<aside class="notes">
<p>
From json.org
</p>

<p>
A json number is considerably more complex to parse than an int.
</p>

<p>
But this can be done&#x2026;
</p>

<p>
You can see here we have some optional values in the parse. <code>option</code> is a useful
combinator to add for that. (Run a parser, and if it fails, return a default value.)
</p>

</aside>

</section>
<section id="slide-orgcf892f0">
<h3 id="orgcf892f0">Problem 2: A JSON string isn't a <code>string_view</code></h3>

<div class="figure">
<p><img src="./json_string.png" alt="json_string.png" />
</p>
</div>

<aside class="notes">
<p>
Strings are quite tricky to parse actually.
</p>

<p>
Non-unicode escaped characters aren't especially hard. We can use <code>operator&lt;</code> to
match and discard a slash, then convert the following character appropriately.
Unicode characters are a little more exacting.
</p>

<p>
The essential point here is that we can't get away with just outputting part of
the <code>string_view</code> that was the input. Parsing strings actually involves
transforming the input into a different, and differently-sized, output.
</p>

<p>
But again, we have all the tools to do this.
</p>

</aside>

</section>
<section id="slide-orgdc86eaa">
<h3 id="orgdc86eaa">Problem 3: Template instantiation</h3>
<div class="org-src-container">

<pre  class="src src-bash">$ time make
<span style="color: #707183;">[</span> <span style="color: #008b8b;">50%</span><span style="color: #707183;">]</span> Building CXX object main.cpp.o
<span style="color: #707183;">[</span><span style="color: #008b8b;">100%</span><span style="color: #707183;">]</span> Linking CXX executable constexpr-all-the-things
<span style="color: #707183;">[</span><span style="color: #008b8b;">100%</span><span style="color: #707183;">]</span> Build target constexpr-all-the-things

real    A BLOODY...
user     LONG...
sys       TIME
$
</pre>
</div>

<aside class="notes">
<p>
We need to get rid of some templates.
</p>

</aside>

</section>
<section id="slide-org99b090f">
<h3 id="org99b090f">Problem 4: Arbitrary Limits</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_parse_depth</span><span style="color: #707183;">{</span><span style="color: #008b8b;">3</span><span style="color: #707183;">}</span>;

<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_vector_size</span><span style="color: #707183;">{</span><span style="color: #008b8b;">6</span><span style="color: #707183;">}</span>;
<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">max_map_size</span><span style="color: #707183;">{</span><span style="color: #008b8b;">6</span><span style="color: #707183;">}</span>;

<span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">cx</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">string</span> = <span style="color: #228b22;">basic_string</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span>, <span style="color: #008b8b;">32</span><span style="color: #7388d6;">&gt;</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Nobody likes arbitrary limits. And these are some pretty small limits, at that.
</p>

</aside>



</section>
<section id="slide-orga7c5c48">
<h3 id="orga7c5c48">Getting Rid Of Template Slowness</h3>
<p>
All this recursive templatery is a problem.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">Depth</span>=<span style="color: #008b8b;">5</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    ...
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::static_string, <span style="color: #228b22;">JSON_Value</span><span style="color: #709870;">&lt;</span>Depth-<span style="color: #008b8b;">1</span><span style="color: #709870;">&gt;</span>, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org39d9671">
<h3 id="org39d9671">Solution: More Parsing!</h3>
<p>
<br />
What we have is a parser for JSON values.<br />
<br />
But we could create more parsers&#x2026;<br />
<br />
</p>
<p class="fragment (appear)">
How about a parser for the <b>number</b> of JSON values required?
</p>

<aside class="notes">
<p>
Of course a parser can produce anything: it doesn't have to produce just JSON
values. If we could parse out the number of values required by a literal, we
could right-size an array of JSON values and then do another pass over the
literal with our actual value parser, outputting into the array.
</p>

</aside>

</section>
<section id="slide-org3ee4495">
<h3 id="org3ee4495">Number-of-values Parser</h3>
<p>
We can write a parser that computes the number of values in a literal:
</p>

<ul>
<li>Array -&gt; 1 + number of values in children</li>
<li>Object -&gt; 1 + number of values in children</li>
<li>Everything else -&gt; 1</li>

</ul>

<p>
We can reuse some structural components of our value parser, and a
number-of-values parser is simpler in many places.
</p>

</section>
<section id="slide-org76d9c20">
<h3 id="org76d9c20">Number-of-values Parser</h3>
<p>
Take the recursive function templates out of our value parser: instead, the
struct itself is a template containing the right-sized array of values.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">recur</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">using</span> <span style="color: #228b22;">V</span> = <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #7388d6;">&lt;</span>JSON_Value, N<span style="color: #7388d6;">&gt;</span>;
  <span style="color: #228b22;">V</span> <span style="color: #a0522d;">vec</span><span style="color: #7388d6;">{}</span>;

  <span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">recur</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">parse_input_t</span> <span style="color: #a0522d;">s</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    value_parser<span style="color: #909183;">(</span>vec<span style="color: #909183;">)(</span>s<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>

  <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">value_parser</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">V</span>&amp; <span style="color: #a0522d;">v</span><span style="color: #7388d6;">)</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
A major source of compilation slowness was instantiating the parser function
templates.
</p>

<p>
The parser functions now do much the same as before except they <code>push_back</code> the
parsed values into the array. And they <code>return</code> the array index of the element
they created.
</p>

<p>
We do the parsing on construction just to make things easy.
</p>

</aside>

</section>
<section id="slide-orgbb4f813">
<h3 id="orgbb4f813">Non-templated <code>JSON_Value</code></h3>
<p>
Now we can have a <code>JSON_Value</code> that isn't a template.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">JSON_Value</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Data</span>
  <span style="color: #7388d6;">{</span>
    ...
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">vector</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">std</span>::size_t, max_vector_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">array</span>;
    <span style="color: #008b8b;">cx</span>::<span style="color: #228b22;">map</span><span style="color: #909183;">&lt;</span><span style="color: #008b8b;">cx</span>::static_string, <span style="color: #008b8b;">std</span>::size_t, max_map_size<span style="color: #909183;">&gt;</span> <span style="color: #a0522d;">object</span>;
  <span style="color: #7388d6;">}</span>;
  ...
<span style="color: #707183;">}</span>;
</pre>
</div>

<p>
The array and object values store offsets into the externalized array.
</p>

<aside class="notes">
<p>
Now that we have externalized the storage of the values, the arrays and objects
inside the <code>JSON_Value</code> store the offsets of their children.
</p>

<p>
I tried having them store pointers to JSON<sub>Values</sub>, but that didn't work
<code>constexpr</code>.
</p>

</aside>

</section>
<section id="slide-org89bf8ea">
<h3 id="org89bf8ea">Example parse</h3>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">jsval</span> = <span style="color: #b22222;">"[1, [2, 3], 4]"</span>_json;
</pre>
</div>
<p>
<br />
Number of values: 6 (2 arrays, 4 numbers)<br />
<br />
<object type="image/svg+xml" data="./array_diagram.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

</section>
<section id="slide-org4a3b686">
<h3 id="org4a3b686">Driving the Parse</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #228b22;">char</span>... <span style="color: #a0522d;">Cs</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">numobjects</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">initializer_list</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">char</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">il</span><span style="color: #7388d6;">{</span>Cs...<span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">numobjects_recur</span><span style="color: #7388d6;">&lt;&gt;</span>::value_parser<span style="color: #7388d6;">()(</span>
      <span style="color: #008b8b;">std</span>::string_view<span style="color: #909183;">(</span>il.begin<span style="color: #709870;">()</span>, il.size<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>-&gt;first;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>, <span style="color: #228b22;">T</span>... <span style="color: #a0522d;">Ts</span><span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span> <span style="color: #b22222;">""</span> _json<span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">constexpr</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">initializer_list</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">il</span><span style="color: #7388d6;">{</span>Ts...<span style="color: #7388d6;">}</span>;
  <span style="color: #a020f0;">return</span> recur<span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">numobjects</span><span style="color: #909183;">&lt;</span>Ts...<span style="color: #909183;">&gt;()</span><span style="color: #7388d6;">&gt;(</span>
      <span style="color: #008b8b;">std</span>::string_view<span style="color: #909183;">(</span>il.begin<span style="color: #709870;">()</span>, il.size<span style="color: #709870;">()</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>.vec;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
In order to get "constexpr arguments" we have to switch to the template version
of the literal operator. That way we can pass the template arguments on to our
numobjects parser.
</p>

<p>
Note we're making a <code>string_view</code> out of the <code>initializer_list</code> expansion.
</p>

<p>
What's returned from the top-level parse is the vector of values. The "root"
value is at index 0.
</p>

</aside>

</section>
<section id="slide-orga71a9eb">
<h3 id="orga71a9eb">Problem 3: Solved</h3>
<p>
<br />
Cost: an extra pass<br />
<br />
Benefits:
</p>
<ul>
<li>quicker compilation (no recursive templates!)</li>
<li>no arbitrary hardcoded limit to depth</li>

</ul>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> jsval = <span style="color: #b22222;">"([[[[[[[[[[[[1]]]]]]]]]]]])"</span>_json;
static_assert<span style="color: #707183;">(</span>jsval<span style="color: #7388d6;">[</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">][</span><span style="color: #008b8b;">0</span><span style="color: #7388d6;">]</span>.to_Number<span style="color: #7388d6;">()</span> == <span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
The cost of the extra pass is much less than the cost of instantiating recursive
templates, especially since the number-of-values parser is much simpler than
the full parser.
</p>

<p>
And arbitrary depth is a significant win.
</p>

</aside>

</section>
<section id="slide-org3af2024">
<h3 id="org3af2024">Problem 4: Arbitrary limits</h3>
<p>
We still have limits on:
</p>

<ul>
<li>string size</li>
<li>array size</li>
<li>object (map) size</li>

</ul>

<p class="fragment appear">
Can we use the same strategy of precomputing size to combat these?
</p>

</section>
<section id="slide-orgedb94ab">
<h3 id="orgedb94ab">Removing string size restriction</h3>
<p>
We <b>can</b> use the same technique:
</p>
<ul>
<li class="fragment appear">precompute the total string size for the value</li>
<li class="fragment appear">rightsize a char buffer</li>
<li class="fragment appear">store <code>{offset, extent}</code> in the string <code>JSON_Value</code> as we parse</li>

</ul>
<p>
<br />
<br />
</p>
<p class="fragment appear">
We can do the number-of-values and total-string-size computation in a single
pass<br />
(that returns the pair of sizes).
</p>

<aside class="notes">
<p>

</p>

</aside>

</section>
<section id="slide-orgcc024ca">
<h3 id="orgcc024ca">String size limit removed</h3>
<p>
<br />
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">jsval</span> = R<span style="color: #b22222;">"(["</span>X<span style="color: #b22222;">", ["</span>ALL<span style="color: #b22222;">", "</span>the<span style="color: #b22222;">"], "</span>things!<span style="color: #b22222;">"])"</span>_json;
</pre>
</div>
<p>
<br />
Number of values: 6 (2 arrays, 4 numbers)<br />
Total string size: 14 (1 + 3 + 3 + 7)<br />
<br />
<object type="image/svg+xml" data="./string_size_diagram.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

</section>
</section>
<section>
<section id="slide-org4f6dea3">
<h2 id="org4f6dea3">The Future</h2>
<aside class="notes">
<p>
Jason to talk through this section.
</p>

</aside>

</section>
<section id="slide-orge506770">
<h3 id="orge506770">The destructor problem</h3>
<p>
Currently any type with a non-trivial destructor cannot be used in <code>constexpr</code> context.
</p>

<p>
trivially destructible quiz time!
</p>

</section>
<section id="slide-org60257ff">
<h3 id="org60257ff"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org2b10a85">
<h3 id="org2b10a85"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>;
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-orga8d8c77">
<h3 id="orga8d8c77"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">unique_ptr</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">i</span>;
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-orgbd2dad7">
<h3 id="orgbd2dad7"><code>is_trivially_destructible</code></h3>
<p>
Does this <code>static_assert</code> succeed?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">S</span> <span style="color: #707183;">{</span>
  ~<span style="color: #0000ff;">S</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{}</span>
<span style="color: #707183;">}</span>;

static_assert<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">is_trivially_destructible_v</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">S</span><span style="color: #7388d6;">&gt;</span><span style="color: #707183;">)</span>;
</pre>
</div>

</section>
<section id="slide-org6e0e15a">
<h3 id="org6e0e15a">Why is this a problem?</h3>
<p>
It's easy to build a <code>constexpr</code> enabled type that can grow at runtime or fail to
compile if it gets too big in <code>constexpr</code> context.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Container</span> <span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">array</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">int</span>, <span style="color: #008b8b;">10</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">data</span><span style="color: #7388d6;">{}</span>;
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">length</span> = <span style="color: #008b8b;">0</span>;
  <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">extra_data</span> = <span style="color: #008b8b;">nullptr</span>;
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_back</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>length &gt;= data.size<span style="color: #709870;">()</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">if</span> <span style="color: #709870;">(</span>!extra_data<span style="color: #709870;">)</span> <span style="color: #709870;">{</span>
        extra_data = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">int</span><span style="color: #907373;">[</span><span style="color: #008b8b;">100</span><span style="color: #907373;">]</span>;
      <span style="color: #709870;">}</span>
      extra_data<span style="color: #709870;">[</span><span style="color: #907373;">(</span>length++<span style="color: #907373;">)</span> - data.size<span style="color: #907373;">()</span><span style="color: #709870;">]</span> = i;
    <span style="color: #909183;">}</span> <span style="color: #a020f0;">else</span> <span style="color: #909183;">{</span>
      data<span style="color: #709870;">[</span>length++<span style="color: #709870;">]</span> = i;
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org889c1fd">
<h3 id="org889c1fd">Why is this a problem?</h3>
<p>
But as soon as we add a destructor, the class is no longer usable in a <code>constexpr</code> context.
</p>

<p>
So we can build this type, but we are required to leak memory if it grows beyond the static size!
</p>

</section>
<section id="slide-org08f898e">
<h3 id="org08f898e">Solutions to the <code>constexpr</code> destructor problem</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Container</span> <span style="color: #707183;">{</span>
  ~<span style="color: #0000ff;">Container</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">this proposal allows for an empty constructor to be allowed</span>
    <span style="color: #a020f0;">if</span> <span style="color: #a020f0;">constexpr</span><span style="color: #909183;">(</span>something<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #bebebe;">// </span><span style="color: #bebebe;">do something</span>
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-orge7c114e">
<h3 id="orge7c114e">Solutions to the <code>constexpr</code> destructor problem</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Container</span> <span style="color: #707183;">{</span>
  ~<span style="color: #0000ff;">Container</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">but why not treat it like any other constexpr code?</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">allow it as long as only constexpr allowed actions</span>
    <span style="color: #bebebe;">// </span><span style="color: #bebebe;">happen at compile time?</span>
    <span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>extra_data<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
      <span style="color: #a020f0;">delete</span> <span style="color: #709870;">[]</span> extra_data;
    <span style="color: #909183;">}</span>
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

</section>
<section id="slide-org38e779d">
<h3 id="org38e779d">The debugging problem</h3>
<p>
On which line does GCC report an error?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span class="linenr"> 1: </span><span style="color: #a020f0;">constexpr</span> <span style="color: #228b22;">int</span> <span style="color: #0000ff;">do_something</span><span style="color: #707183;">()</span>
<span class="linenr"> 2: </span><span style="color: #707183;">{</span>
<span class="linenr"> 3: </span>  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">val</span><span style="color: #7388d6;">[</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">]{}</span>;
<span class="linenr"> 4: </span>  <span style="color: #a020f0;">return</span> val<span style="color: #7388d6;">[</span><span style="color: #008b8b;">1</span><span style="color: #7388d6;">]</span>;
<span class="linenr"> 5: </span><span style="color: #707183;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span>
<span class="linenr"> 8: </span><span style="color: #707183;">{</span>
<span class="linenr"> 9: </span>  <span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> val = do_something<span style="color: #7388d6;">()</span>;
<span class="linenr">10: </span><span style="color: #707183;">}</span>
</pre>
</div>

</section>
<section id="slide-orgc83eab6">
<h3 id="orgc83eab6">The debugging problem</h3>
<p>
Several times during debugging we had to take the code from compile time context 
to runtime context to allow for actual debugging.
</p>

</section>
<section id="slide-org421d8af">
<h3 id="org421d8af">The debugging problem</h3>
<p>
This proposal adds debugging capability at compile time.
</p>


<div class="figure">
<p><img src="./constexpr_trace.png" alt="constexpr_trace.png" />
</p>
</div>

</section>
<section id="slide-orgb28187e">
<h3 id="orgb28187e"><code>constexpr_vector</code></h3>
<p>
This other proposal from the same author allows for a special type of <code>constexpr_vector</code>
that is allowed to grow and shrink at compile time only, requiring compiler support.
</p>


<div class="figure">
<p><img src="./constexpr_vector.png" alt="constexpr_vector.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgd85b991">
<h2 id="orgd85b991"><code>constexpr</code> STL possibilities</h2>
<div class="outline-text-2" id="text-orgd85b991">
</div></section>
<section id="slide-orgfb7c9a9">
<h3 id="orgfb7c9a9">algorithms</h3>
<p>
Weakened complexity guarantees on <code>stable_sort</code>, <code>inplace_merge</code>, <code>stable_partition</code>?
(They make use of temporary buffers to improve complexity.)
</p>

<p>
Are there others that might need to have weakened complexity guarantees for compile time use?
</p>

</section>
<section id="slide-orgdd6d1e7">
<h3 id="orgdd6d1e7">iterators</h3>
<p>
If you have a <code>constexpr</code> container, you want the iterators to all be <code>constexpr</code>.
</p>

<p>
Many iterators could be <code>constexpr</code> and usable in a <code>constexpr</code> context if the
operations on the corresponding containers are.
</p>

<p>
e.g. if you have <code>constexpr push_back</code> on your <code>constexpr vector</code> type, then
<code>back_insert_iterator</code> could easily be <code>constexpr</code>.
</p>

</section>
</section>
<section>
<section id="slide-org1f114c1">
<h2 id="org1f114c1">The Cost</h2>
<div class="outline-text-2" id="text-org1f114c1">
</div></section>
<section id="slide-org4f36613">
<h3 id="org4f36613">Cognitive Cost</h3>
<ul>
<li class="fragment appear">Flat data structures are easy to reason about</li>
<li class="fragment appear"><code>constexpr</code> code forces you to consider what your code is doing and the lifetime of objects (in a good way).</li>
<li class="fragment appear">Tree like data structures are difficult to reason about</li>
<li class="fragment appear">Selecting data structure sizes can be difficult</li>

</ul>

</section>
<section id="slide-org24cc2f4">
<h3 id="org24cc2f4">Compile-time Cost - Debug Build</h3>
<ul>
<li class="fragment appear">6GB RAM!</li>
<li class="fragment appear">&gt;2 Minutes Build Time</li>
<li class="fragment appear">338K Binary</li>
<li class="fragment appear">Tweaking debug level can have a great effect. This might be related to symbol sizes.</li>

</ul>

</section>
<section id="slide-org8f7caa5">
<h3 id="org8f7caa5">Compile-time Cost - Release Build</h3>
<ul>
<li class="fragment appear">328MB RAM</li>
<li class="fragment appear">5s Build Time</li>
<li class="fragment appear">9K Binary</li>

</ul>

</section>
<section id="slide-orgc082565">
<h3 id="orgc082565">Compile-time Cost - Comparison</h3>
<p>
Using the same nightly build of GCC, how long does this take to compile?
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #483d8b;">#include</span> <span style="color: #707183;">&lt;</span><span style="color: #b22222;">regex</span><span style="color: #707183;">&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span><span style="color: #707183;">()</span>
<span style="color: #707183;">{</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">regex</span> <span style="color: #0000ff;">attribute</span><span style="color: #7388d6;">(</span>R<span style="color: #b22222;">"(\s+(\S+)\s*=\s*('|"</span><span style="color: #7388d6;">)(</span>.*?<span style="color: #7388d6;">)</span>\<span style="color: #008b8b;">2</span><span style="color: #88090B;">)</span><span style="color: #000000; background-color: #ffa500; font-weight: bold;">"</span><span style="color: #b22222;">);</span>
<span style="color: #b22222;">}</span>
</pre>
</div>

<p class="fragment (appear)">
5s Debug, 7.5s Release
</p>

</section>
</section>
<section>
<section id="slide-org2379118">
<h2 id="org2379118">Conclusion</h2>
<ul>
<li>All but 3 standard algorithms can easily be made <code>constexpr</code></li>
<li>There are holes around assignment operations in the STL</li>
<li>Some interaction with C, ie <code>&lt;cmath&gt;</code> may hold back some operations</li>
<li><code>constexpr</code> allocators and <code>constexpr</code> destructors would make it possible to fully unify <code>constexpr</code> versions of containers with regular</li>

</ul>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
