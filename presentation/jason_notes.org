# Implementation Notes

* Earlier misunderstanding with compiler prevented use of `union` in a `constexpr` context. That was resolved. Getting initialization right can be "hard"
* Without `constexpr` support for lambdas in C++17, much of this would be much harder
* Many algorithms that are not currently `constexpr` could be made such. 
  - `find_if`
  - `mismatch`
  - `equal`
  - `copy`
* `std::optional` 
  - Gets the hard part right: it's trivially destructable if the contained type is
  - However, gets everything else wrong - non-`constexpr` copy/move/assignment
  - Making it functionally useless in a `constexpr` context
* `std::variant`
  - See `std::optional`
* `map` and `vector` is easy to implement, even with iterator support. The only thing that makes it hard deciding the size ahead of time. 
* I personally found the `static_string` class for a fixed-size wrapper around a `char *` literal to be very helpful. It is like a `string_view` but with more restrictions so you know you can store it (I think) 
 
# General Notes
 
* Debugging issues is hard
* Tests are surprisingly easy. There's no risk of something going wrong at runtime, if a test compiles, it worked!
* What about use cases for mixed-mode `constexpr` with fixed-size storage that optionally expands (is Eric Neibler around? He worked on this with his string class)
* Compile times are tricky to manage, but it could be worse. The hard part - which Ben will speak about - is building / flattening trees. Really this is not a `constexpr` issue, but a template issue in our cases.

# The Future

* What about overloading on `constexpr` usage?
* Can we remove the restriction on trivial destructors?
* What is the status on allowing dynamic allocations? 

