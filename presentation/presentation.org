#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: toc:nil <:nil timestamp:nil email:t reveal_slide_number:"c/t"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: blood
#+REVEAL_HLEVEL: 1
#+REVEAL_EXTRA_CSS: ./presentation.css
#+REVEAL_ROOT: ./reveal.js/

#+TITLE: constexpr ALL the things!
#+AUTHOR: Ben Deane & Jason Turner
#+EMAIL: bdeane@blizzard.com, jason@emptycrate.com
#+DATE: May 16th, 2017

#+REVEAL_HTML: <script type="text/javascript" src="./presentation.js"></script>

* Title slide settings                                             :noexport:
#+BEGIN_SRC emacs-lisp
(setq org-reveal-title-slide
(concat "<img src=\"title.png\">"
"<h3>Ben Deane / <a href=\"mailto:bdeane@blizzard.com\">bdeane@blizzard.com</a> / "
"<a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3>"
"<h3>Jason Turner / <a href=\"mailto:jason@emptycrate.com\">jason@emptycrate.com</a> / "
"<a href=\"http://twitter.com/lefticus\">@lefticus</a></h3>"
"<h4>C++Now / Tuesday 16th May 2017</h4>"))
#+END_SRC

* Don't Bury The Lede

We want to do this:

#+BEGIN_SRC c++
  constexpr auto jsv
    = R"({
          "feature-x-enabled": true,
          "value-of-y": 1729,
          "z-options": {"a": null,
                        "b": "220 and 284",
                        "c": [6, 28, 496]}
         })"_json;
  if constexpr (jsv["feature-x-enabled"]) {
    // code for feature x
  } else {
    // code when feature x turned off
  }
#+END_SRC

#+BEGIN_NOTES
When I first heard about ~constexpr~ I immediately thought of the potential for
this: generating compile-time data structures with UDLs. And JSON is an obvious
choice for a proof-of-concept.

Why JSON?
 - not too difficult (small grammar, well known)
 - sufficiently interesting (deal with recursive structure at compile time
   without memory management)
 - ubiquitous, useful?
#+END_NOTES

* The Promise of ~constexpr~
 - Runtime efficiency
 - Clearer code, fewer magic numbers
 - Less cross-platform pain

#+BEGIN_NOTES
Jason talks about this.

Doing work at compile-time instead of runtime. Obvious gain.

Simplifying code through compile-time computation. No need for manual math,
preprocessor computation "to be sure", magic numbers.

Reducing steps in the toolchain. Don't maintain generation scripts: put it in
the C++.
#+END_NOTES

*  ~constexpr~ History 101
A Short, Incomplete (and Mostly Wrong?) History of ~constexpr~

#+BEGIN_NOTES
Ben to drive this section.
#+END_NOTES

** ~constexpr~: The First Age
#+ATTR_REVEAL: :frag (appear)
 - One (~return~) expression per function was allowed
 - ~constexpr~ math functions explored
 - ~throw~ link error trick discovered
 - Recursive ~constexpr~ FNV1 string hash discovered

#+BEGIN_NOTES
C++11 constexpr was "extreme recursion" but many things were doable nonetheless.

Scott Schurr's talks at CppNow/CppCon hinted at things to come and expounded on
the throw trick for forcing compile-time evaluation.
#+END_NOTES

** ~constexpr~: End of the First Age
#+BEGIN_SRC c++
// 1. Fall of Gondolin
// 2. Balrogs destroyed
// 3. Morgoth defeated and cast into the Timeless Void
// 4. constexpr string hashing discovered

constexpr uint64_t fnv1(uint64_t h, const char* s)
{
  return (*s == 0) ? h :
    fnv1((h * 1099511628211ull) ^ static_cast<uint64_t>(*s), s+1);
}
#+END_SRC

#+BEGIN_NOTES
At this point most people are probably familiar with this or something like it.
#+END_NOTES

** ~constexpr~: The Second Age
#+ATTR_REVEAL: :frag (appear)
 - Generalized ~constexpr~ supported by Visual C++
 - Compile-time computation/optimization popularized by [[https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1][/C++ Weekly/]] et al.
 - Generalized ~constexpr~ string hashing (e.g. Murmur3) discovered
 - ~constexpr~ libraries start to appear

#+BEGIN_NOTES
For some reason, the major application of ~constexpr~ reported in the mainstream
seems to be string hashing.
#+END_NOTES

** ~constexpr~: End of the Second Age
[[./cpp14_murmur.png]]

(Also: Last Alliance of Elves & Men, Isildur takes up the hilt of Narsil\\
and cuts the One Ring from Sauron's hand.)

** ~constexpr~: The Third Age?
#+ATTR_REVEAL: :frag (appear)
 - ~constexpr~ lambdas
 - ~if constexpr~
 - ~constexpr~ STL proliferation?
 - (coming soon, no doubt) ~constexpr~ cryptographic hashes

#+BEGIN_NOTES
~constexpr~ lambdas are a really powerful thing (as we shall see).

~if constexpr~ replaces many ~std::enable_if~ uses, more.

A selection of interesting ~constexpr~ things in the STL: ~string_view~,
~array~, almost all of ~chrono~.

New STL features are born with ~constexpr~ (somewhat) in mind: ~optional~,
~variant~.
#+END_NOTES

* A problem with ~constexpr~

[[./constexpr_problem.png]]

The inability to use different runtime and compile time algorithms.

** ~constexpr~ SFINAE?

A partial solution, perhaps.

#+BEGIN_SRC c++
constexpr auto str_view = "Computers are useless."sv;
constexpr auto cx_hash = fnv1(str_view);

auto str = "They can only give you answers."s;
auto rt_hash = fnv1(str);
#+END_SRC

We would /like/ the second call to ~fnv1~ to use an efficient runtime algorithm.

** ~constexpr~ SFINAE?

You /can/ do something like this...

#+BEGIN_SRC c++
template <typename T>
constexpr auto booler(T) { return true; }

template <typename T>
using constexpr_construct_t = std::integral_constant<bool, booler(T{})>;
#+END_SRC

And then feed it to the detection idiom.

#+BEGIN_NOTES
If ~T~ is ~constexpr~ constructible, it will be admissible as a compile-time
argument to ~booler~, and therefore the result will be a well-formed template
argument.

~booler~ is similar to ~void_t~ here.

Whatever expression we put in the arugment to booler will have to be evaluated
at compile time in order for the type to be well-formed. And we can then use
this type with the new detection idiom.
#+END_NOTES

** ~constexpr~ SFINAE?

#+BEGIN_SRC c++
template <typename StringType>
constexpr auto fnv1(const StringType& s)
{
  if constexpr(is_detected_v<constexpr_construct_t, StringType>) {
    return cx::fnv1(s);
  } else {
    return runtime::fnv1(s);
  }
}
#+END_SRC

Caveats: many.
#+ATTR_REVEAL: :frag (appear)
 - "~constexpr~ constructible" doesn't mean "~constexpr~ hashable"
 - "~constexpr~ capable" doesn't mean "in a ~constexpr~ context"
 - verbosity, compile time?

#+BEGIN_NOTES
If you're going to go with this kind of thing, you might as well define
completely different types for use at compile time and runtime.
#+END_NOTES

** ~constexpr~ SFINAE?

Another possible (better) solution.

[[./constexpr_operator.png]]

* Building ~constexpr~ JSON Values

Two problems to solve:

1. How to represent JSON values
1. How to parse JSON values

* Representing JSON Values

A JSON Value is a discriminated union of:\\
\\
#+ATTR_REVEAL: :frag (appear)
 - null
 - boolean
 - number
 - string
 - array of values
 - object (map of string -> value)

#+ATTR_REVEAL: :frag (appear)
\\
Clearly this is going to need some sort of recursion. And we are going to need
~constexpr~ ways to deal with a string, a vector and a map.

#+BEGIN_NOTES
Jason to drive this section.
#+END_NOTES

** ~constexpr~ strings
\\
First, ~std::string_view~ is great, and /mostly/ ~constexpr~\\
(depending on how up-to-date your library implementation is).\\
\\
\\
Of course, ~std::string_view~ only really handles literal values:\\
it doesn't deal with building strings, and is not intended for /storing/ strings.

#+BEGIN_NOTES
~string_view~ comparison is not yet ~constexpr~.
#+END_NOTES

** ~constexpr~ strings
\\
We need a way to pass, store, and in general, work with\\
character string literals.\\
\\
\\
While ~std::string_view~ would technically work for this\\
it kind of mixes metaphors, since it is not intended for storing\\
and comparison - just viewing.\\
\\
\\
For this, we built up the ~static_string~ class.

** ~constexpr~ strings
#+BEGIN_SRC c++
struct static_string
{
  template <std::size_t N>
  constexpr static_string(const char (&str)[N])
    : m_size(N-1), m_data(&str[0])
  {}

  // constructor for substrings of string literals
  constexpr static_string(const char* str, std::size_t s)
    : m_size(s), m_data(str)
  {}

  constexpr static_string() = default;

  constexpr size_t size() const { return m_size; }
  constexpr const char *c_str() const { return m_data; }

  std::size_t m_size{0};
  const char *m_data = nullptr;
};
#+END_SRC

** ~constexpr~ vectors

#+BEGIN_SRC c++
template <typename Value, std::size_t Size = 5>
class vector
{
  using storage_t = std::array<Value, Size>;
  storage_t m_data{};
  std::size_t m_size{0};
  ...

  // iterators, push_back, operator[] etc
  // are pretty easy to write
}
#+END_SRC

#+BEGIN_NOTES
Obviously we need to know the max size at compile time.
#+END_NOTES

** ~constexpr~ vectors

#+BEGIN_SRC c++
using iterator = typename storage_t::iterator;
using const_iterator = typename storage_t::const_iterator;

constexpr auto begin() const { return m_data.begin(); }
constexpr auto end() const { return m_data.begin() + m_size; }
// and similarly for other iterator functions...

constexpr void push_back(Value t_v)
{
  if (m_size >= Size) {
    throw std::range_error("Index past end of vector");
  } else {
    m_data[m_size++] = std::move(t_v);
  }
}
#+END_SRC

We were not able to use ~std::next()~ here, seems to be a bug in the implementation...

#+BEGIN_NOTES
Note that the ~throw~ here is a nicety: if we were to read/write past the end of
a ~constexpr~ array the compiler would give an error anyway. Assuming we are working
in a ~constexpr~ context. This throw protects us if this class is used just for a handy
statically sized vector.
#+END_NOTES

** Why not ~std::next~?

In GCC's implementation: internal ~__iterator_category~ is not ~constexpr~ constructible.

#+REVEAL_HTML: <iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Carray%3E%0A%23include+%3Citerator%3E%0A%0Ausing+namespace+std%3B%0A%0Aconstexpr+array%3Cint,+5%3E+foo+%3D+%7B1,2,3,4,5%7D%3B%0A%0Aconstexpr+auto+third_of_foo()%0A%7B%0A++return+next(foo.cbegin(),+3)%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+i+%3D+*third_of_foo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.5479341055999998,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:21.627408993576015,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:78.37259100642399,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

** ~constexpr~ vectors

This allows for natural use of the ~vector~ type

#+BEGIN_SRC c++
vector<int> vec;
vec.push_back(15);
#+END_SRC

** ~constexpr~ vectors

Or put into a ~constexpr~ context

#+BEGIN_SRC c++
constexpr auto get_vector() {
  vector<int> vec;
  vec.push_back(15);
  return vec;
}

int main() {
  constexpr auto a_vector = get_vector();
  static_assert(a_vector.size() == 1);
}
#+END_SRC

** mutable ~constexpr~ strings

And now we can build a mutable ~constexpr~ string by inheriting from our ~vector~

** mutable ~constexpr~ strings

#+BEGIN_SRC c++
template <typename CharType, size_t Size>
struct basic_string : vector<CharType, Size>
{
  constexpr basic_string(const static_string &s) 
    : vector<CharType, Size>(s.begin(), s.end())
  {}
  constexpr basic_string(const std::string_view &s)
    : vector<CharType, Size>(s.cbegin(), s.cend())
  {}
  // ...
};
#+END_SRC

This relies on:
 - ~constexpr~ data members must be initialized, so our base vector is all ~0~
 - We have not provided any methods for shrinking our data structures, but that is possible

** ~constexpr~ maps

#+BEGIN_SRC c++
template <typename Key, typename Value, std::size_t Size = 5>
class map
{
  using storage_t = std::array<cx::pair<Key, Value>, Size>;
  storage_t m_data{};
  std::size_t m_size{0};
  ...

  // iterators are the same as for arrays
  // operator[] needs a constexpr find
  // data grows in the same way that vector does
}
#+END_SRC

** ~constexpr~ maps

#+BEGIN_SRC c++
  auto get_colors() {
    cx::map<cx::static_string, std::uint32_t> colors;
    colors["red"] = 0xFF0000;
    colors["green"] = 0x00FF00;
    return colors;
  }

  int main() {
    constexpr colors = get_colors();
    colors["red"]; // returns 0xFF0000
    colors["blue"]; // compile-time error
  }
#+END_SRC

** Why not ~std::pair~?

Standard library definition does not have ~constexpr operator=~ \\
for ~std::pair~\\
\\
This is the only aspect of ~std::pair~ that is not ~constexpr~

#+REVEAL_HTML: <iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Cutility%3E%0A%0Ausing+namespace+std%3B%0A%0Astruct+P+%0A%7B%0A++std::pair%3Cconst+char*,+int%3E+pr%3B%0A%7D%3B%0A%0Aconstexpr+auto+pair_test()%0A%7B%0A++P+p%3B%0A++p.pr+%3D+make_pair(%22taxicab%22,+1729)%3B%0A++return+p%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+p+%3D+pair_test()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.2899450879999999,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:19.48608137044968,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:80.51391862955032,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

** ~constexpr find_if~

#+BEGIN_SRC c++
template <class InputIt, class UnaryPredicate>
constexpr InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
{
  for (; first != last; ++first) {
    if (p(*first)) {
      return first;
    }
  }
  return last;
}
#+END_SRC

#+BEGIN_NOTES
There's no technical reason for many algorithms not to be ~constexpr~.
#+END_NOTES

** Let's make them all ~constexpr~ already

[[./bryce_tweet.png]]

** Other algorithms we made ~constexpr~

 - ~mismatch~
 - ~equal~
 - ~copy~

In the course of implementing this talk, we found uses for several ~constexpr~
algorithms.

** JSON Value: First attempt

#+BEGIN_SRC c++
template <size_t Depth=5>
struct JSON_Value
{
  static constexpr size_t max_vector_size{6};
  static constexpr size_t max_map_size{6};

  struct Data
  {
    bool boolean{false};
    double number{0};
    cx::static_string string;
    cx::vector<JSON_Value<Depth-1>, max_vector_size> array;
    cx::map<cx::static_string, JSON_Value<Depth-1>, max_map_size> object;
  };
  enum struct Type { Null, Boolean, Number, String, Array, Object };

  Type type = Type::Null;
  Data data;
  ...
};

template <> struct JSON_Value<0> {};
#+END_SRC

#+BEGIN_NOTES
This makes for a lot of template instantiations, and has some obvious limitations.

The max sizes for arrays and objects are determined empirically.
#+END_NOTES

** JSON Value: First attempt

#+BEGIN_SRC c++
struct JSON_Value
{
  constexpr void assert_type(Type t) const
  {
    if (type != t) throw std::runtime_error("Incorrect type");
  }

  // For Array, and similarly for the other types
  constexpr decltype(auto) to_Array() const
  {
    assert_type(Type::Array);
    return (data.array);
  }
  constexpr decltype(auto) to_Array()
  {
    if (type != Type::Array) {
      type = Type::Array;
      data.array = {};
    }
    return (data.array);
  }
};
#+END_SRC

** JSON Value: First attempt

#+BEGIN_SRC c++
cx::JSON_Value j{};
j["a"].to_Number() = 15;
j["b"].to_String() = "Hello World";
j["d"].to_Array();
j["c"]["a"]["b"].to_Array().push_back(10.0);
j["c"]["a"]["c"] = cx::static_string("Hello World");
j["c"]["a"]["d"].to_Array().push_back(5.2);
#+END_SRC

#+BEGIN_NOTES
But this kind of thing works. Note that we are using C++17 class template type
deduction here so we don't need to say ~cx::JSON_Value<> j{};~
#+END_NOTES

** Why not ~std::variant~ ?

Similarly to ~std::pair~, ~std::variant~ is missing some key ~constexpr~ support.

#+ATTR_REVEAL: :frag (appear)
 - ~std::variant(const std::variant &)~
 - ~std::variant(std::variant &&)~
 - ~std::variant &operator=(const std::variant &)~
 - ~std::variant &operator=(std::variant &&)~

** Requirements for compile-time types

Huge list! Are you ready?! 

#+ATTR_REVEAL: :frag (appear)
 - ~constexpr~ constructor
 - ~std::is_trivially_destructible~ 

#+ATTR_REVEAL: :frag (appear)
Nothing else is required if it does not get invoked.

** STL shortcomings

 - ~array~
 - ~string~
 - ~string_view~
 - ~pair~
 - ~optional~
 - ~variant~
 - ~swap~

#+BEGIN_NOTES
Many of these parts of the STL have ~constexpr~ desires and partially
~constexpr~ friendly implementations.

In our experience, none of them quite achieves everything that is possibly
~constexpr~. In many cases this could just be an oversight in the implementation
or the standard and not because of some deep reason.
#+END_NOTES

** Limitations of our containers
 
 - Fixed maximum size
 - (Currently) cannot shrink
 * Requires types that are default constructible 

** How to improve our containers
 
 - We could wrap objects in ~std::optional~ to allow for objects that are not default constructible
 - It should be possible to templatize on ~constexpr~ enabled allocator, making these containers optionally ~constexpr~

** ~constexpr~ allocator?

From cppreference.com

#+BEGIN_SRC c++
template <class T>
struct SimpleAllocator {
  typedef T value_type;
  SimpleAllocator(/*ctor args*/);
  template <class U> SimpleAllocator(const SimpleAllocator<U>& other);
  T* allocate(std::size_t n);
  void deallocate(T* p, std::size_t n);
};
template <class T, class U>
bool operator==(const SimpleAllocator<T>&, const SimpleAllocator<U>&);
template <class T, class U>
bool operator!=(const SimpleAllocator<T>&, const SimpleAllocator<U>&);
#+END_SRC

** ~constexpr~ allocator?

#+BEGIN_SRC c++
template <class T, size_t Size>
struct ConstexprAllocator {
  typedef T value_type;
  consstexpr ConstexprAllocator(/*ctor args*/);
  template <class U> 
  constexpr ConstexprAllocator(const ConstexprAllocator<U>& other);
  constexpr T* allocate(std::size_t n);
  constexpr  void deallocate(T* p, std::size_t n);
  std::array<std::pair<bool, value_type>, Size> data; // bool for free flag
};
#+END_SRC

Implementation left as an exercise to the reader.

* Parsing JSON Value Literals

Because we need some way to actually turn a string literal into our JSON
representation.

#+BEGIN_NOTES
Ben drives this section.
#+END_NOTES

** What is a Parser?
\\
#+BEGIN_SRC haskell
Parser a :: String -> [(a, String)]
#+END_SRC
"A parser for things is a function from strings to lists of pairs of things and strings."

-- [[http://www.willamette.edu/~fruehr/haskell/seuss.html][Dr Seuss on parsers]]\\
\\
\\
Or in our case something like:
#+BEGIN_SRC c++
template <typename T>
using parser = auto (*)(string) -> list<pair<T, string>>;
#+END_SRC

#+BEGIN_NOTES
This serendipitous phrase is due to Fritz Ruehr, a functional programming
lecturer at Willamette University.
#+END_NOTES

** Parsers

#+BEGIN_SRC c++
template <typename T>
using parser = auto (*)(string) -> list<pair<T, string>>;
#+END_SRC

Of course, we don't really mean quite this...

#+ATTR_REVEAL: :frag (appear)
 - ~string~ -> ~string_view~ (compile-time stringlike thing)
 - ~list~ -> ~optional~ (simpler)
 - "function" -> "something invocable"

#+BEGIN_NOTES
Strings are any stringlike thing - ~string_view~ will do nicely since we're just
reading this from a literal. The input is obvious, the output is the leftover
part of the string after parsing a T.

List represents optionality - a given string might have several ways it can be
parsed. For simplicity we can just assume one way or error, i.e. optional.

Of course we'll use the ~constexpr~ friendly ~pair~.

And when we say "function" we mean the usual invocable things. Including ~constexpr~
lambdas!
#+END_NOTES

** A Simple Parser

Let's have a couple of aliases that will make life simpler.
#+BEGIN_SRC c++
using parse_input_t = std::string_view;

template <typename T>
using parse_result_t = cx::optional<cx::pair<T, parse_input_t>>;
#+END_SRC

And let's make a parser that matches a single ~char~ that we give it.
#+BEGIN_SRC c++
auto match_char(parse_input_t s, char c) -> parse_result_t<char>
{
  if (s.empty() || s[0] != c) return std::nullopt;
  return parse_result_t<char>(
    cx::make_pair(c, parse_input_t(s.data()+1, s.size()-1)));
}
#+END_SRC

#+BEGIN_NOTES
This is what a parser does: either matches or not (hence the optional) and if it
matches, returns the value matched and the rest of the string for use in future
parsers.
#+END_NOTES

** A Simple Parser
#+BEGIN_SRC c++
// Ceci n'est pas une parser.
auto match_char(parse_input_t s, char c) -> parse_result_t<char>;
#+END_SRC

~match_char~ isn't actually a parser, because it has the wrong signature.\\
\\

#+BEGIN_SRC c++
// This is the signature of a parser.
template <typename T>
using parser = auto (*)(parse_input_t s) -> parse_result_t<T>;
#+END_SRC

But now that we have ~constexpr~ lambdas, we can write a function that returns a
parser.

** A Simple Parser
#+BEGIN_SRC c++
constexpr auto make_char_parser(char c)
{
  return [=] (parse_input_t s) -> parse_result_t<char> {
    if (s.empty() || s[0] != c) return std::nullopt;
    return parse_result_t<char>(
        cx::make_pair(c, parse_input_t(s.data()+1, s.size()-1)));
  };
}
#+END_SRC
The lambda returned from ~make_char_parser~ is a parser that will match the
given ~char~.

** More useful primitive parsers
So far we can match one ~char~. Because fundamentally parsing works on
"strings", there are a couple of other parsers that will be useful.

#+BEGIN_SRC c++
// parse one of a set of chars
constexpr auto one_of(std::string_view chars)
{
  return [=] (parse_input_t s) -> parse_result_t<char> {
    if (s.empty()) return std::nullopt;
    // basic_string_view::find is supposed to be constexpr, but no...
    auto j = cx::find(chars.cbegin(), chars.cend(), s[0]);
    if (j != chars.cend()) {
      return parse_result_t<char>(
          cx::make_pair(s[0], parse_input_t(s.data()+1, s.size()-1)));
    }
    return std::nullopt;
  };
}
#+END_SRC

** More useful primitive parsers

And you can imagine how to write these.

#+BEGIN_SRC c++
// the opposite of one_of: match a char that isn't any of the given set
constexpr auto none_of(std::string_view chars)
{
  return [=] (parse_input_t s) -> parse_result_t<char> {
    ...
  };
}

// match a given string
constexpr auto make_string_parser(std::string_view str)
{
  return [=] (parse_input_t s) -> parse_result_t<std::string_view> {
    // here we could use a constexpr version of std::mismatch...
    ...
  };
}
#+END_SRC

** Building up
\\
So far we have a few primitive parsers.\\
\\
\\
In order to simply build up more complex parsers, we need to be able to\\
*combine* parsers in various ways.

** Building up
Some basic things we will want to do:

 - Change the result type of a parser (~fmap~)
 - Run one parser, then a second one based on what the first returned (~bind~)
 - Run one parser, and if it fails run another (~operator|~)
 - Run two parsers in succession and combine the outputs (~combine~)

(Pick your functional pattern: functor, monad, monoid, applicative...)

#+BEGIN_NOTES
Some suggested names for the operations involved.

"Change the result type" = run a function on the result to turn it into something else.

~operator|~ is the monoid operation (with the parser that always fails as the unit).

~combine~ is the applicative operation.

I'll show you a few of these combinators so you can get a feel for them.
#+END_NOTES

** Changing the result type (~fmap~)
#+BEGIN_SRC haskell
fmap :: (a -> b) -> Parser a -> Parser b
#+END_SRC

#+BEGIN_SRC c++
template <typename F, typename P>
constexpr auto fmap(F&& f, P&& p)
{
  using R = parse_result_t<std::result_of_t<F(parse_t<P>)>>;
  return [f = std::forward<F>(f),
          p = std::forward<P>(p)] (parse_input_t i) -> R {
           const auto r = p(i);
           if (!r) return std::nullopt;
           return R(cx::make_pair(f(r->first), r->second));
         };
}
#+END_SRC

#+BEGIN_NOTES
~parse_t~ here is just a way of getting the parsed type back out of the parser
without all the optional/pair business.

Note what fmap returns is a parser.

Think about a simple case of turning a char into an int.
#+END_NOTES

** Alternation (~operator|~)
#+BEGIN_SRC haskell
operator| :: Parser a -> Parser a -> Parser a
#+END_SRC

#+BEGIN_SRC c++
  template <typename P1, typename P2,
            std::enable_if_t<std::is_same_v<parse_t<P1>, parse_t<P2>>, int> = 0>
  constexpr auto operator|(P1&& p1, P2&& p2) {
    return [=] (parse_input_t i) {
      const auto r1 = p1(i);
      if (r1) return r1;
      return p2(i);
    };
  }
#+END_SRC

#+BEGIN_SRC c++
  template <typename T>
  constexpr auto fail(T) {
    return [=] (parse_input_t) -> parse_result_t<T> {
      return std::nullopt;
    };
  }
#+END_SRC

#+BEGIN_NOTES
Alternation is the monoid operation. ~fail~ is the identity.
#+END_NOTES

** Conjunction (~combine~)
#+BEGIN_SRC haskell
combine :: Parser a -> Parser b -> (a -> b -> c) -> Parser c
#+END_SRC

#+BEGIN_SRC c++
  template <typename P1, typename P2, typename F,
            typename R = std::result_of_t<F(parse_t<P1>, parse_t<P2>)>>
  constexpr auto combine(P1&& p1, P2&& p2, F&& f) {
    return [=] (parse_input_t i) -> parse_result_t<R> {
             const auto r1 = p1(i);
             if (!r1) return std::nullopt;
             const auto r2 = p2(r1->second);
             if (!r2) return std::nullopt;
             return parse_result_t<R>(
                 cx::make_pair(f(r1->first, r2->first), r2->second));
           };
  }
#+END_SRC

#+BEGIN_NOTES
~combine~ is a bit like ~fmap~ for multiple-argument functions. In some sense
the applicative operation.

Note that both parsers need to succeed, and we run the second parser on what is
leftover from the first, then return what is leftover from the second.
#+END_NOTES

** Useful ~combine~ patterns
#+BEGIN_SRC haskell
operator> :: Parser a -> Parser b -> Parser a
operator< :: Parser a -> Parser b -> Parser b
#+END_SRC

#+BEGIN_SRC c++
  template <typename P1, typename P2,
            typename = parse_t<P1>, typename = parse_t<P2>>
  constexpr auto operator<(P1&& p1, P2&& p2) {
    return combine(std::forward<P1>(p1),
                   std::forward<P2>(p2),
                   [] (auto, const auto& r) { return r; });
  }
#+END_SRC

These operators are useful for throwing away the left or right hand side of ~combine~.

#+BEGIN_NOTES
These simple formulations of combine are very useful. They allow us to run
multiple parsers in succession, keeping just the left hand side or the right
hand side.

And of course the operators are symmetric and left-associative.
#+END_NOTES

** Accumulating combinators
And now you begin to see where this is heading...

#+BEGIN_SRC haskell
many :: Parser a -> b -> (b -> a -> b)  -> Parser b
many1 :: Parser a -> b -> (b -> a -> b)  -> Parser b
exactly_n :: Parser a -> int -> b -> (b -> a -> b) -> Parser b
separated_by :: Parser a -> Parser x -> b -> (b -> a -> b) -> Parser b
#+END_SRC

These are starting to look like building blocks we can use to parse real things.

#+BEGIN_NOTES
Explain each of these function signatures.
#+END_NOTES

** Some simple examples
This parser eats whitespace.

#+BEGIN_SRC c++
  constexpr auto skip_whitespace()
  {
    constexpr auto ws_parser =
      make_char_parser(' ')
      | make_char_parser('\t')
      | make_char_parser('\n')
      | make_char_parser('\r');
    return many(ws_parser, std::monostate{}, [] (auto m, auto) { return m; });
  }
#+END_SRC

#+BEGIN_NOTES
Alternation of each individual parser.

Then many (zero or more) of the resulting parser.

The key to all the combinators is that what they return are themselves parsers.
Composition!
#+END_NOTES

** Some simple examples
This parses a decimal integer.
#+BEGIN_SRC c++
  constexpr auto int_parser()
  {
    return bind(one_of("123456789"sv),
                [] (char x, parse_input_t rest) {
                  return many(one_of("0123456789"sv),
                              static_cast<int>(x - '0'),
                              [] (int acc, char c) { return (acc*10) + (c-'0'); })(rest);
                });
  }
#+END_SRC
First any non-zero digit, then zero or more digits,\\
building up the integer in the obvious way.

#+BEGIN_NOTES
Note that ~bind~'s second argument carries the leftover string through as well
as the parse result of the first argument.
#+END_NOTES

** Some simple examples
This (very simply) parses a string.
#+BEGIN_SRC c++
  constexpr auto string_parser()
  {
    constexpr auto quote_parser = make_char_parser('"');
    const auto str_parser =
      many(none_of("\""sv),
           std::string_view(s.data()+1, 0),
           [] (const auto& acc, auto) {
             return std::string_view(acc.data(), acc.size()+1);
           });
    return quote_parser < str_parser > quote_parser;
  }
#+END_SRC

#+BEGIN_NOTES
For the sake of simplicity, we aren't dealing with escaped characters, unicode
points, etc.

In fact for this simple example we are accumulating a ~string_view~. But in
general when we come to parse escaped characters, the input characters don't
have a 1-to-1 mapping with the output characters.
#+END_NOTES

** Getting to JSON
We now have a toolkit for building parsers.
#+BEGIN_SRC c++
  template <size_t Depth=5>
  struct JSON_Value
  {
    ...
    struct Data
    {
      bool boolean{false};
      double number{0};
      cx::static_string string;
      cx::vector<JSON_Value<Depth-1>, max_vector_size> array;
      cx::map<cx::static_string, JSON_Value<Depth-1>, max_map_size> object;
    };
    ...
  };
#+END_SRC
To parse our JSON value, a reasonable approach is to use\\
alternation on parsers for each type of value.

#+BEGIN_NOTES
We're going to have 6 different parsers, each of which produces a ~JSON_Value~,
and we're going to alternate them together.

They will be mutually recursive: the parsers for objects and arrays call the
value parsers.

In order to achieve mutual recursion, we'll put them in a struct. (The next
couple of slides contain a lot of code - sorry.)
#+END_NOTES

** Recursive parsing structure

#+BEGIN_SRC c++
  struct recur
  {
    template <std::size_t Depth = max_parse_depth>
    static constexpr auto value_parser()
    {
      constexpr auto p =
        fmap([] (std::string_view) { return JSON_Value<Depth>(std::monostate{}); },
             make_string_parser("null"sv))
        | fmap([] (std::string_view) { return JSON_Value<Depth>(true); },
               make_string_parser("true"sv))
        | fmap([] (std::string_view) { return JSON_Value<Depth>(false); },
               make_string_parser("false"sv))
        | fmap([] (auto n) { return JSON_Value<Depth>(n); },
               number_parser())
        | fmap([] (auto str) { return JSON_Value<Depth>(str); },
               string_parser())
        | array_parser<Depth>()
        | object_parser<Depth>();
      return skip_whitespace() < p;
    }
    ...
#+END_SRC

#+BEGIN_NOTES
~value_parser~ is the top level entry point to our parser.

Each argument of alternation must return the same type: in this case, they are
~JSON_Value~ parsers, obtained from each other parse type by fmapping in an
appropriate function.

Note the way we eat whitespace before a value. Easy with the applicative
operator. It would be "easy" to sprinkle ~skip_whitespace()~ everywhere and it
would work... but a more disciplined approach is to eating whitespace *before*
the parses that need it.
#+END_NOTES

** Recursive parsing structure

#+BEGIN_SRC c++
    ...
    template <std::size_t Depth = max_parse_depth>
    static constexpr auto array_parser() { ... }

    template <std::size_t Depth = max_parse_depth>
    static constexpr auto key_value_parser() { ... }

    template <std::size_t Depth = max_parse_depth>
    static constexpr auto object_parser() { ... }
  };

  template <>
  constexpr auto recur::value_parser<0>() {
    return fail(JSON_Value<0>{});
  }

  constexpr auto operator "" _json(const char* str, std::size_t len) {
    return recur::value_parser<>()(std::string_view{str, len});
  }
#+END_SRC

#+BEGIN_NOTES
The body of everything is too much code to show, but you can imagine how these
work.

For ~array_parser~, we parse an open square bracket, then we use our
~separated_by~ combinator to parse values separated by commas, then we parse a
closing square bracket. The JSON value we return is an array type value which
has had its array member accumulated with the comma-separated values we parsed.

Object parser is similar, but open/close curly braces, and key-value pairs
separated by commas. A key-value pair is itself a string followed by a colon
followed by a value.

Each time we recurse through ~value_parser~, we decrement the ~Depth~
template value to produce the next level of the JSON tree.

Note the use of ~fail~: an easy way to provide the right type for the base case.
#+END_NOTES

** Error messages
#+BEGIN_SRC c++
  template <typename T, typename ErrorFn>
  constexpr auto fail(T, ErrorFn f) {
    return [=] (parse_input_t) -> parse_result_t<T> {
      f();
      return std::nullopt;
    };
  }

  static constexpr auto array_parser() {
    return ...
      > (make_char_parser(']') | fail(']', [] { throw "expected ]"; }));
  }
#+END_SRC

It's not a very good story.

#+BEGIN_NOTES
Support for error messages during compile time parsing is very rudimentary.

This is the best I came up with: a fail parser that will throw and cause a
compile error. So it tells you what went wrong, but it can't tell you anything
about what it was parsing or where the error was.

A bit more about this later.
#+END_NOTES

* Parsing JSON Value Literals (Better)
\\
What we have so far is the simplest proof-of-concept.\\
\\
\\
It works (for suitable values of "works").\\
\\
\\
It's a good starting point, but there are a few problems we need to address.

#+BEGIN_NOTES
What we have so far is a good starting point. The parsing toolkit is pretty useful.
#+END_NOTES

** Problem 1: A JSON number isn't an ~int~

[[./json_number.png]]

#+BEGIN_NOTES
From json.org

A json number is considerably more complex to parse than an int.

But this can be done...

You can see here we have some optional values in the parse. ~option~ is a useful
combinator to add for that. (Run a parser, and if it fails, return a default value.)
#+END_NOTES

** Problem 2: A JSON string isn't a ~string_view~

[[./json_string.png]]

#+BEGIN_NOTES
Strings are quite tricky to parse actually.

Non-unicode escaped characters aren't especially hard. We can use ~operator<~ to
match and discard a slash, then convert the following character appropriately.
Unicode characters are a little more exacting.

The essential point here is that we can't get away with just outputting part of
the ~string_view~ that was the input. Parsing strings actually involves
transforming the input into a different, and differently-sized, output.

But again, we have all the tools to do this.
#+END_NOTES

** Problem 3: Template instantiation

#+BEGIN_SRC bash
$ time make
[ 50%] Building CXX object main.cpp.o
[100%] Linking CXX executable constexpr-all-the-things
[100%] Build target constexpr-all-the-things

real    A BLOODY...
user     LONG...
sys       TIME
$
#+END_SRC

#+BEGIN_NOTES
We need to get rid of some templates.
#+END_NOTES

** Problem 4: Arbitrary Limits

#+BEGIN_SRC c++
constexpr inline std::size_t max_parse_depth{3};

static constexpr size_t max_vector_size{6};
static constexpr size_t max_map_size{6};

namespace cx
{
  using string = basic_string<char, 32>;
}
#+END_SRC

#+BEGIN_NOTES
Nobody likes arbitrary limits. And these are some pretty small limits, at that.
#+END_NOTES

** Getting Rid Of Template Slowness
All this recursive templatery is a problem.

#+BEGIN_SRC c++
  template <size_t Depth=5>
  struct JSON_Value
  {
    struct Data
    {
      ...
      cx::vector<JSON_Value<Depth-1>, max_vector_size> array;
      cx::map<cx::static_string, JSON_Value<Depth-1>, max_map_size> object;
    };
    ...
  };
#+END_SRC

** Solution: More Parsing!
\\
What we have is a parser for JSON values.\\
\\
But we could create more parsers...\\
\\
#+ATTR_REVEAL: :frag (appear)
How about a parser for the *number* of JSON values required?

#+BEGIN_NOTES
Of course a parser can produce anything: it doesn't have to produce just JSON
values. If we could parse out the number of values required by a literal, we
could right-size an array of JSON values and then do another pass over the
literal with our actual value parser, outputting into the array.
#+END_NOTES

** Number-of-values Parser
We can write a parser that computes the number of values in a literal:

 - Array -> 1 + number of values in children
 - Object -> 1 + number of values in children
 - Everything else -> 1

We can reuse some structural components of our value parser, and a
number-of-values parser is simpler in many places.

** Number-of-values Parser

Take the recursive function templates out of our value parser: instead, the
struct itself is a template containing the right-sized array of values.

#+BEGIN_SRC c++
  template <std::size_t N>
  struct recur
  {
    using V = cx::vector<JSON_Value, N>;
    V vec{};

    constexpr recur(parse_input_t s) {
      value_parser(vec)(s);
    }

    static constexpr auto value_parser(V& v);
    ...
  };
#+END_SRC

#+BEGIN_NOTES
A major source of compilation slowness was instantiating the parser function
templates.

The parser functions now do much the same as before except they ~push_back~ the
parsed values into the array. And they ~return~ the array index of the element
they created.

We do the parsing on construction just to make things easy.
#+END_NOTES

** Non-templated ~JSON_Value~
Now we can have a ~JSON_Value~ that isn't a template.

#+BEGIN_SRC c++
  struct JSON_Value
  {
    struct Data
    {
      ...
      cx::vector<std::size_t, max_vector_size> array;
      cx::map<cx::static_string, std::size_t, max_map_size> object;
    };
    ...
  };
#+END_SRC

The array and object values store offsets into the externalized array.

#+BEGIN_NOTES
Now that we have externalized the storage of the values, the arrays and objects
inside the ~JSON_Value~ store the offsets of their children.

I tried having them store pointers to JSON_Values, but that didn't work
~constexpr~.
#+END_NOTES

** Example parse
\\
#+BEGIN_SRC c++
  auto jsval = "[1, [2, 3], 4]"_json;
#+END_SRC
\\
Number of values: 6 (2 arrays, 4 numbers)\\
\\
[[./array_diagram.svg]]

** Driving the Parse
#+BEGIN_SRC c++
  template <char... Cs>
  constexpr auto numobjects()
  {
    std::initializer_list<char> il{Cs...};
    return numobjects_recur<>::value_parser()(
        std::string_view(il.begin(), il.size()))->first;
  }

  template <typename T, T... Ts>
  constexpr auto operator "" _json()
  {
    constexpr std::initializer_list<T> il{Ts...};
    return recur<numobjects<Ts...>()>(
        std::string_view(il.begin(), il.size())).vec;
  }
#+END_SRC

#+BEGIN_NOTES
In order to get "constexpr arguments" we have to switch to the template version
of the literal operator. That way we can pass the template arguments on to our
numobjects parser.

Note we're making a ~string_view~ out of the ~initializer_list~ expansion.

What's returned from the top-level parse is the vector of values. The "root"
value is at index 0.
#+END_NOTES

** Problem 3: Solved
\\
Cost: an extra pass\\
\\
Benefits:
 - quicker compilation (no recursive templates!)
 - no arbitrary hardcoded limit to depth
\\
#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC c++
constexpr auto jsval = "([[[[[[[[[[[[1]]]]]]]]]]]])"_json;
static_assert(jsval[0][0][0][0][0][0][0][0][0][0][0][0][0].to_Number() == 1);
#+END_SRC

#+BEGIN_NOTES
The cost of the extra pass is much less than the cost of instantiating recursive
templates, especially since the number-of-values parser is much simpler than
the full parser.

And arbitrary depth is a significant win.
#+END_NOTES

** Problem 4: Arbitrary limits
We still have limits on:

 - string size
 - array size
 - object (map) size

#+ATTR_REVEAL: :frag appear
Can we use the same strategy of precomputing size to combat these?

** Removing string size restriction

We *can* use the same technique:
#+ATTR_REVEAL: :frag (appear)
 - precompute the total string size for the value
 - rightsize a char buffer
 - store ~{offset, extent}~ in the string ~JSON_Value~ as we parse
\\
\\
#+ATTR_REVEAL: :frag appear
We can do the number-of-values and total-string-size computation in a single
pass\\
(that returns the pair of sizes).

#+BEGIN_NOTES
Structural bindings don't work ~constexpr~.
#+END_NOTES

** String size limit removed
\\
#+BEGIN_SRC c++
  auto jsval = R"(["X", ["ALL", "the"], "things!"])"_json;
#+END_SRC
\\
Number of values: 6 (2 arrays, 4 numbers)\\
Total string size: 14 (1 + 3 + 3 + 7)\\
\\
[[./string_size_diagram.svg]]

** Remaining limits
We still have limits on:

 - array size
 - object (map) size

We can't naively do the same thing we did with strings, because values within
arrays/objects aren't contiguous.

#+BEGIN_NOTES
We would like to be able to represent arrays as ~{offset, extent}~ but this is
only possible if the values contained within the array are stored contiguously.
#+END_NOTES

** Arrays/Objects Aren't Contiguous
As we saw before, because of arbitrary nesting.
\\
#+BEGIN_SRC c++
  auto jsval = "[1, [2, 3], 4]"_json;
#+END_SRC
\\
[[./array_diagram.svg]]

#+BEGIN_NOTES
This is because of the inherent depth-first traversal of parsing.

So how can we make the storage of the compound values contiguous?
#+END_NOTES

** Add another pass
Add a pass to make the parser "breadth-first".

#+BEGIN_SRC c++
  struct JSON_Value
  {
    union Data
    {
      std::string_view unparsed;
      bool boolean;
      double number;
      ...
    };
    ...
  };
#+END_SRC

#+BEGIN_NOTES
We're parsing a ~string_view~ that represents a JSON value. Every JSON value
contained is a ~string_view~ inside the top-level ~string_view~.

All we need is a parser that returns the ~string_view~ for its value. We can
then use it to parse the children of the array value and store each as an
unparsed ~string_view~. Contiguously!
#+END_NOTES

** "Breadth-first" Parsing
Now the array is parsed contiguously.
\\
#+BEGIN_SRC c++
  auto jsval = "[1, [2, 3], 4]"_json;
#+END_SRC
\\
[[./breadth_first_diagram.svg]]

#+BEGIN_NOTES
The diagram shows the intermediate stage of parsing the array.

Once the array is parsed so that its immediate children occupy contiguous
storage, we go back and parse its children again into "real" JSON values that
are appended in the storage.
#+END_NOTES

** As Arrays, so Objects
\\
Arrays are now ~{offset, extent}~, so there is no limit on array size.\\
\\
Objects could be arrays of (string, value).\\
\\
We just need to deal with object keys.

#+BEGIN_NOTES
There is one remaining limit: the size of an object key (because it's a string).

Well, now JSON values are small, and can store arbitrary length strings... so we
might as well store an object key as a JSON value.
#+END_NOTES

** Object storage
Objects are alternating strings and arbitrary values.
\\
#+BEGIN_SRC c++
  auto jsval = R"({"McKern":2,  "McGoohan":6})"_json;
#+END_SRC
\\
[[./object_diagram.svg]]

#+BEGIN_NOTES
Of course, 6 here should really be NaN. Perhaps that's another talk :)
#+END_NOTES

** Finally, no limits!
#+BEGIN_SRC c++
  struct JSON_Value
  {
    struct ExternalView {
      std::size_t offset;
      std::size_t extent;
    };

    union Data {
      std::string_view unparsed;
      bool boolean;
      double number;
      ExternalView external_string;
      ExternalView external_array;
      ExternalView external_object;
    };
    ...
  };
#+END_SRC

#+BEGIN_NOTES
This is the final representation of a JSON value as produced by our parsing
scheme.
#+END_NOTES

** Parsing: Conclusion
#+ATTR_REVEAL: :frag (appear)
 - ~constexpr~ lambdas enable composable compile-time parsing
 - parser combinators enable more complex literals
 - multiple passes can be used thanks to template UDL operators and ~string_view~
 - adding extra passes can solve almost any problem...
 - could parsing be helped by a (good?) C++ concept?

* The Future

#+BEGIN_NOTES
Jason to talk through this section.
#+END_NOTES

** The destructor problem

Currently any type with a non-trivial destructor cannot be used in ~constexpr~ context.

trivially destructible quiz time!

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
};

static_assert(std::is_trivially_destructible_v<S>);
#+END_SRC

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
  int i;
};

static_assert(std::is_trivially_destructible_v<S>);
#+END_SRC

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
  std::unique_ptr<int> i;
};

static_assert(std::is_trivially_destructible_v<S>);
#+END_SRC

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
  ~S() {}
};

static_assert(std::is_trivially_destructible_v<S>);
#+END_SRC

** Why is this a problem?

It's easy to build a ~constexpr~ enabled type that can grow at runtime or fail to
compile if it gets too big in ~constexpr~ context.

#+BEGIN_SRC c++
struct Container {
  std::array<int, 10> data{};
  std::size_t length = 0;
  int *extra_data = nullptr;
  void push_back(const int i) {
    if (length >= data.size()) {
      if (!extra_data) {
        extra_data = new int[100];
      }
      extra_data[(length++) - data.size()] = i;
    } else {
      data[length++] = i;
    }
  }
};
#+END_SRC

** Why is this a problem?

But as soon as we add a destructor, the class is no longer usable in a ~constexpr~ context.

So we can build this type, but we are required to leak memory if it grows beyond the static size!

** Solutions to the ~constexpr~ destructor problem

#+BEGIN_SRC c++
struct Container {
  ~Container() {
    // this proposal allows for an empty constructor to be allowed
    if constexpr(something) {
      // do something
    }
  }
};
#+END_SRC

** Solutions to the ~constexpr~ destructor problem

#+BEGIN_SRC c++
struct Container {
  ~Container() {
    // but why not treat it like any other constexpr code?
    // allow it as long as only constexpr allowed actions
    // happen at compile time?
    if (extra_data) {
      delete [] extra_data;
    }
  }
};
#+END_SRC

** The debugging problem

On which line does GCC report an error?

#+BEGIN_SRC c++ -n
constexpr int do_something()
{
  int val[1]{};
  return val[1];
}

int main()
{
  constexpr auto val = do_something();
}
#+END_SRC

** The debugging problem

Several times during debugging we had to take the code from compile time context 
to runtime context to allow for actual debugging.

** The debugging problem

This proposal adds debugging capability at compile time.

[[./constexpr_trace.png]]

#+BEGIN_NOTES
This would be useful for reporting parse errors on ~constexpr~ literals.
#+END_NOTES

** ~constexpr_vector~

This other proposal from the same author allows for a special type of ~constexpr_vector~
that is allowed to grow and shrink at compile time only, requiring compiler support.

[[./constexpr_vector.png]]

* ~constexpr~ STL possibilities
** algorithms
Weakened complexity guarantees on ~stable_sort~, ~inplace_merge~, ~stable_partition~?
(They make use of temporary buffers to improve complexity.)

Are there others that might need to have weakened complexity guarantees for compile time use?

** iterators
If you have a ~constexpr~ container, you want the iterators to all be ~constexpr~.

Many iterators could be ~constexpr~ and usable in a ~constexpr~ context if the
operations on the corresponding containers are.

e.g. if you have ~constexpr push_back~ on your ~constexpr vector~ type, then
~back_insert_iterator~ could easily be ~constexpr~.

* The Cost
** Cognitive Cost

#+ATTR_REVEAL: :frag (appear)
 - Flat data structures are easy to reason about
 - ~constexpr~ code forces you to consider what your code is doing and the lifetime of objects (in a good way).
 - Tree like data structures are difficult to reason about
 - Selecting data structure sizes can be difficult
 - Error messages from heavily composed lambdas are... challenging to deal with
 - Debugging currently means "go back and think about the types"

** Compile-time Cost - Debug Build

#+ATTR_REVEAL: :frag (appear)
 - 6GB RAM!
 - >2 Minutes Build Time
 - 338K Binary
 - Tweaking debug level can have a great effect. This might be related to symbol sizes.

#+BEGIN_NOTES
Explain exactly *what* is being built here?
#+END_NOTES

** Compile-time Cost - Release Build

#+ATTR_REVEAL: :frag (appear)
 - 328MB RAM
 - 5s Build Time
 - 9K Binary

** Compile-time Cost - Comparison

Using the same nightly build of GCC, how long does this take to compile?

#+BEGIN_SRC c++
#include <regex>

int main()
{
  std::regex attribute(R"(\s+(\S+)\s*=\s*('|")(.*?)\2)");
}
#+END_SRC

#+ATTR_REVEAL: :frag (appear)
5s Debug, 7.5s Release

* Conclusion

 * All but 3 standard algorithms can (easily?) be made ~constexpr~
 - (And maybe ~stable_sort~, ~stable_partition~ and ~inplace_merge~ could work ~constexpr~ without a buffer)
 * There are holes around assignment operations in the STL
 - Many iterator operations could be made ~constexpr~ for use with ~constexpr~ containers
 * Some interaction with C, ie ~<cmath>~ may hold back some operations
 * ~constexpr~ allocators and ~constexpr~ destructors would make it possible to fully unify ~constexpr~ versions of containers with regular
