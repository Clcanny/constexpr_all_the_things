#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: toc:nil <:nil timestamp:nil email:t reveal_slide_number:"c/t"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: blood
#+REVEAL_HLEVEL: 1
#+REVEAL_EXTRA_CSS: ./presentation.css
#+REVEAL_ROOT: ./reveal.js/

#+TITLE: constexpr ALL the things!
#+AUTHOR: Ben Deane & Jason Turner
#+EMAIL: bdeane@blizzard.com, jason@emptycrate.com
#+DATE: May 16th, 2017

#+REVEAL_HTML: <script type="text/javascript" src="./presentation.js"></script>

* Title slide settings                                             :noexport:
#+BEGIN_SRC emacs-lisp
(setq org-reveal-title-slide
(concat "<img src=\"title.png\">"
"<h3>Ben Deane / <a href=\"mailto:bdeane@blizzard.com\">bdeane@blizzard.com</a> / "
"<a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3>"
"<h3>Jason Turner / <a href=\"mailto:jason@emptycrate.com\">jason@emptycrate.com</a> / "
"<a href=\"http://twitter.com/lefticus\">@lefticus</a></h3>"
"<h4>C++Now / Tuesday 16th May 2017</h4>"))
#+END_SRC

* Don't Bury The Lede

We want to do this:

#+BEGIN_SRC c++
constexpr auto jsv
  = R"({
        "feature-x-enabled": true,
        "value-of-y": 1729,
        "z-options": {"a": null,
                      "b": "220 and 284",
                      "c": [6, 28, 496]}
       })"_json;
if constexpr (jsv["feature-x-enabled"]) {
  // code for feature x
} else {
  // code when feature x turned off
}
#+END_SRC

#+BEGIN_NOTES
When I first heard about ~constexpr~ I immediately thought of the potential for
this: generating compile-time data structures with UDLs. And JSON is an obvious
choice for a proof-of-concept.
#+END_NOTES

* The Promise of ~constexpr~
 - Runtime efficiency
 - Clearer code, fewer magic numbers
 - Less cross-platform pain

#+BEGIN_NOTES
Doing work at compile-time instead of runtime. Obvious gain.

Simplifying code through compile-time computation. No need for manual math,
preprocessor computation "to be sure", magic numbers.

Reducing steps in the toolchain. Don't maintain generation scripts: put it in
the C++.
#+END_NOTES

*  ~constexpr~ History 101
A Short, Incomplete (and Mostly Wrong?) History of ~constexpr~

** ~constexpr~: The First Age
#+ATTR_REVEAL: :frag (appear)
 - One (~return~) expression per function was allowed
 - ~constexpr~ math functions explored
 - ~throw~ link error trick discovered
 - Recursive ~constexpr~ FNV1 string hash discovered

#+BEGIN_NOTES
C++11 constexpr was "extreme recursion" but many things were doable nonetheless.

Scott Schurr's talks at CppNow/CppCon hinted at things to come and expounded on
the throw trick for forcing compile-time evaluation.
#+END_NOTES

** ~constexpr~: End of the First Age
#+BEGIN_SRC c++
// 1. Fall of Gondolin
// 2. Balrogs destroyed
// 3. Morgoth defeated and cast into the Timeless Void
// 4. constexpr string hashing discovered

constexpr uint64_t fnv1(uint64_t h, const char* s)
{
  return (*s == 0) ? h :
    fnv1((h * 1099511628211ull) ^ static_cast<uint64_t>(*s), s+1);
}
#+END_SRC

#+BEGIN_NOTES
At this point most people are probably familiar with this or something like it.
#+END_NOTES

** ~constexpr~: The Second Age
#+ATTR_REVEAL: :frag (appear)
 - Generalized ~constexpr~ supported by Visual C++
 - Compile-time computation/optimization popularized by [[https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1][/C++ Weekly/]] et al.
 - Generalized ~constexpr~ string hashing (e.g. Murmur3) discovered
 - ~constexpr~ libraries start to appear

#+BEGIN_NOTES
For some reason, the major application of ~constexpr~ reported in the mainstream
seems to be string hashing.
#+END_NOTES

** ~constexpr~: End of the Second Age
[[./cpp14_murmur.png]]

(Also: Last Alliance of Elves & Men, Isildur takes up the hilt of Narsil\\
and cuts the One Ring from Sauron's hand.)

** ~constexpr~: The Third Age?
#+ATTR_REVEAL: :frag (appear)
 - ~constexpr~ lambdas
 - ~if constexpr~
 - ~constexpr~ STL proliferation?
 - (coming soon, no doubt) ~constexpr~ cryptographic hashes

#+BEGIN_NOTES
~constexpr~ lambdas are a really powerful thing (as we shall see).

~if constexpr~ replaces many ~std::enable_if~ uses, more.

A selection of interesting ~constexpr~ things in the STL: ~string_view~,
~array~, almost all of ~chrono~.

New STL features are born with ~constexpr~ (somewhat) in mind: ~optional~,
~variant~.
#+END_NOTES

* A problem with ~constexpr~

[[./constexpr_problem.png]]

The inability to use different runtime and compile time algorithms.

** ~constexpr~ SFINAE?

A partial solution, perhaps.

#+BEGIN_SRC c++
constexpr auto str_view = "Computers are useless."sv;
constexpr auto cx_hash = fnv1(str_view);

auto str = "They can only give you answers."s;
auto rt_hash = fnv1(str);
#+END_SRC

We would /like/ the second call to ~fnv1~ to use an efficient runtime algorithm.

** ~constexpr~ SFINAE?

You /can/ do something like this...

#+BEGIN_SRC c++
template <bool>
using true_t = std::true_type;

template <typename T>
constexpr auto has_constexpr_default_constructor(int) -> true_t<(T{}, true)>;

template <typename>
constexpr auto has_constexpr_default_constructor(...) -> std::false_type;

template <typename T>
struct is_constexpr_default_constructible
  : decltype(has_constexpr_default_constructor<T>(0)){};
#+END_SRC


** ~constexpr~ SFINAE?

#+BEGIN_SRC c++
template <typename StringType>
constexpr auto fnv1(const StringType& s)
{
  if constexpr(is_constexpr_default_constructible<StringType>::value) {
    return cx::fnv1(s);
  } else {
    return runtime::fnv1(s);
  }
}
#+END_SRC

Caveats: many.
#+ATTR_REVEAL: :frag (appear)
 - "~constexpr~ constructible" doesn't mean "~constexpr~ hashable"
 - "~constexpr~ capable" doesn't mean "in a ~constexpr~ context"
 - verbosity, compile time?

#+BEGIN_NOTES
If you're going to go with this kind of thing, you might as well define
completely different types for use at compile time and runtime.
#+END_NOTES

** ~constexpr~ SFINAE?

Another possible (better) solution.

[[./constexpr_operator.png]]

* Building ~constexpr~ JSON Values

Two problems to solve:

1. How to represent JSON values
1. How to parse JSON values

* Representing JSON Values

A JSON Value is a discriminated union of:\\
\\
#+ATTR_REVEAL: :frag (appear)
 - null
 - boolean
 - number
 - string
 - array of values
 - object (map of string -> value)

#+ATTR_REVEAL: :frag (appear)
\\
Clearly this is going to need some sort of recursion. And we are going to need
~constexpr~ ways to deal with a string, a vector and a map.

** ~constexpr~ strings
\\
First, ~std::string_view~ is great, and /mostly/ ~constexpr~\\
(depending on how up-to-date your library implementation is).\\
\\
\\
Of course, ~std::string_view~ only really handles literal values:\\
it doesn't deal with building strings, and is not intended for /storing/ strings.

#+BEGIN_NOTES
~string_view~ comparison is not yet ~constexpr~.
#+END_NOTES

** ~constexpr~ strings
\\
We need a way to pass, store, and in general, work with\\
character string literals.\\
\\
\\
While ~std::string_view~ would technically work for this\\
it kind of mixes metaphors, since it is not intended for storing\\
and comparison - just viewing.\\
\\
\\
For this, we built up the ~static_string~ class.

** ~constexpr~ strings
#+BEGIN_SRC c++
struct static_string
{
  template <std::size_t N>
  constexpr static_string(const char (&str)[N])
    : m_size(N-1), m_data(&str[0])
  {}

  // constructor for substrings of string literals
  constexpr static_string(const char* str, std::size_t s)
    : m_size(s), m_data(str)
  {}

  constexpr static_string() = default;

  constexpr size_t size() const { return m_size; }
  constexpr const char *c_str() const { return m_data; }

  std::size_t m_size{0};
  const char *m_data = nullptr;
};
#+END_SRC

** ~constexpr~ vectors

#+BEGIN_SRC c++
template <typename Value, std::size_t Size = 5>
class vector
{
  using storage_t = std::array<Value, Size>;
  storage_t m_data{};
  std::size_t m_size{0};
  ...

  // iterators, push_back, operator[] etc
  // are pretty easy to write
}
#+END_SRC

#+BEGIN_NOTES
Obviously we need to know the max size at compile time.
#+END_NOTES

** ~constexpr~ vectors

#+BEGIN_SRC c++
using iterator = typename storage_t::iterator;
using const_iterator = typename storage_t::const_iterator;

constexpr auto begin() const { return m_data.begin(); }
constexpr auto end() const { return m_data.begin() + m_size; }
// and similarly for other iterator functions...

constexpr void push_back(Value t_v)
{
  if (m_size >= Size) {
    throw std::range_error("Index past end of vector");
  } else {
    m_data[m_size++] = std::move(t_v);
  }
}
#+END_SRC

We were not able to use ~std::next()~ here, seems to be a bug in the implementation...

#+BEGIN_NOTES
Note that the ~throw~ here is a nicety: if we were to read/write past the end of
a ~constexpr~ array the compiler would give an error anyway. Assuming we are working
in a ~constexpr~ context. This throw protects us if this class is used just for a handy
statically sized vector.
#+END_NOTES


** Why not ~std::next~?

In GCC's implementation: internal ~__iterator_category~ is not ~constexpr~ constructible.

#+REVEAL_HTML: <iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Carray%3E%0A%23include+%3Citerator%3E%0A%0Ausing+namespace+std%3B%0A%0Aconstexpr+array%3Cint,+5%3E+foo+%3D+%7B1,2,3,4,5%7D%3B%0A%0Aconstexpr+auto+third_of_foo()%0A%7B%0A++return+next(foo.cbegin(),+3)%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+i+%3D+*third_of_foo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.5479341055999998,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:21.627408993576015,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:78.37259100642399,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

** ~constexpr~ vectors

This allows for natural use of the ~vector~ type

#+BEGIN_SRC c++
vector<int> vec;
vec.push_back(15);
#+END_SRC

** ~constexpr~ vectors

Or put into a ~constexpr~ context

#+BEGIN_SRC c++
constexpr auto get_vector() {
  vector<int> vec;
  vec.push_back(15);
  return vec;
}

int main() {
  constexpr auto a_vector = get_vector();
  static_assert(a_vector.size() == 1);
}
#+END_SRC

** mutable ~constexpr~ strings

And now we can build a mutable ~constexpr~ string by inheriting from our ~vector~

** mutable ~constexpr~ strings

#+BEGIN_SRC c++
template <typename CharType, size_t Size>
struct basic_string : vector<CharType, Size>
{
  constexpr basic_string(const static_string &s) 
    : vector<CharType, Size>(s.begin(), s.end())
  {}
  constexpr basic_string(const std::string_view &s)
    : vector<CharType, Size>(s.cbegin(), s.cend())
  {}
  // ...
};
#+END_SRC

This relies on:
 - ~constexpr~ data members must be initialized, so our base vector is all ~0~
 - We have not provided any methods for shrinking our data structures, but that is possible

** ~constexpr~ maps

#+BEGIN_SRC c++
template <typename Key, typename Value, std::size_t Size = 5>
class map
{
  using storage_t = std::array<cx::pair<Key, Value>, Size>;
  storage_t m_data{};
  std::size_t m_size{0};
  ...

  // iterators are the same as for arrays
  // operator[] needs a constexpr find
  // data grows in the same way that vector does
}
#+END_SRC

** ~constexpr~ maps

#+BEGIN_SRC c++
  auto get_colors() {
    cx::map<cx::static_string, std::uint32_t> colors;
    colors["red"] = 0xFF0000;
    colors["green"] = 0x00FF00;
    return colors;
  }

  int main() {
    constexpr colors = get_colors();
    colors["red"]; // returns 0xFF0000
    colors["blue"]; // compile-time error
  }
#+END_SRC

** Why not ~std::pair~?

Standard library definition does not have ~constexpr operator=~ \\
for ~std::pair~\\
\\
This is the only aspect of ~std::pair~ that is not ~constexpr~

#+REVEAL_HTML: <iframe width="1400px" height="600px" src="https://gcc.godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:1.2899450879999999,j:1,source:'%23include+%3Cutility%3E%0A%0Ausing+namespace+std%3B%0A%0Astruct+P+%0A%7B%0A++std::pair%3Cconst+char*,+int%3E+pr%3B%0A%7D%3B%0A%0Aconstexpr+auto+pair_test()%0A%7B%0A++P+p%3B%0A++p.pr+%3D+make_pair(%22taxicab%22,+1729)%3B%0A++return+p%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++constexpr+auto+p+%3D+pair_test()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:44.41586064715348,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),fontScale:1.2899450879999999,options:'-std%3Dc%2B%2B1z+-O3+-Wall+-Wextra',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:43.26069218283827,l:'4',m:19.48608137044968,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:80.51391862955032,n:'0',o:'',s:0,t:'0')),k:55.58413935284653,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

** ~constexpr find_if~

#+BEGIN_SRC c++
template <class InputIt, class UnaryPredicate>
constexpr InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
{
  for (; first != last; ++first) {
    if (p(*first)) {
      return first;
    }
  }
  return last;
}
#+END_SRC

#+BEGIN_NOTES
There's no technical reason for many algorithms not to be ~constexpr~.
#+END_NOTES

** Let's make them all ~constexpr~ already

[[./bryce_tweet.png]]

** Other algorithms we made ~constexpr~

 - ~mismatch~
 - ~equal~
 - ~copy~

** JSON Value: First attempt

#+BEGIN_SRC c++
template <size_t Depth=5>
struct JSON_Value
{
  static constexpr size_t max_vector_size{6};
  static constexpr size_t max_map_size{6};

  struct Data
  {
    bool boolean{false};
    double number{0};
    cx::static_string string;
    cx::vector<JSON_Value<Depth-1>, max_vector_size> array;
    cx::map<cx::static_string, JSON_Value<Depth-1>, max_map_size> object;
  };
  enum struct Type { Null, Boolean, Number, String, Array, Object };

  Type type = Type::Null;
  Data data;
  ...
};

template <> struct JSON_Value<0> {};
#+END_SRC

#+BEGIN_NOTES
This makes for a lot of template instantiations, and has some obvious limitations.

The max sizes for arrays and objects are determined empirically.
#+END_NOTES

** JSON Value: First attempt

#+BEGIN_SRC c++
struct JSON_Value
{
  constexpr void assert_type(Type t) const
  {
    if (type != t) throw std::runtime_error("Incorrect type");
  }

  // For Array, and similarly for the other types
  constexpr decltype(auto) to_Array() const
  {
    assert_type(Type::Array);
    return (data.array);
  }
  constexpr decltype(auto) to_Array()
  {
    if (type != Type::Array) {
      type = Type::Array;
      data.array = {};
    }
    return (data.array);
  }
};
#+END_SRC

** JSON Value: First attempt

#+BEGIN_SRC c++
cx::JSON_Value j{};
j["a"].to_Number() = 15;
j["b"].to_String() = "Hello World";
j["d"].to_Array();
j["c"]["a"]["b"].to_Array().push_back(10.0);
j["c"]["a"]["c"] = cx::static_string("Hello World");
j["c"]["a"]["d"].to_Array().push_back(5.2);
#+END_SRC

#+BEGIN_NOTES
But this kind of thing works. Note that we are using C++17 class template type
deduction here so we don't need to say ~cx::JSON_Value<> j{};~
#+END_NOTES

** Why not ~std::variant~ ?

Similarly to ~std::pair~, ~std::variant~ is missing some key ~constexpr~ support.

#+ATTR_REVEAL: :frag (appear)
 - ~std::variant(const std::variant &)~
 - ~std::variant(std::variant &&)~
 - ~std::variant &operator=(const std::variant &)~
 - ~std::variant &operator=(std::variant &&)~

** Requirements for compile-time types

Huge list! Are you ready?! 

#+ATTR_REVEAL: :frag (appear)
 - ~constexpr~ constructor
 - ~std::is_trivially_destructible~ 

#+ATTR_REVEAL: :frag (appear)
Nothing else is required if it does not get invoked.

** STL shortcomings

 - ~array~
 - ~string~
 - ~string_view~
 - ~pair~
 - ~optional~
 - ~variant~
 - ~swap~

** Limitations of our containers
 
 - Fixed maximum size
 - (Currently) cannot shrink
 * Requires types that are default constructible 

** How to improve our containers
 
 - We could wrap objects in ~std::optional~ to allow for objects that are not default constructible
 - It should be possible to templatize on ~constexpr~ enabled allocator, making these containers optionally ~constexpr~

* Parsing JSON Value Literals

** What is a Parser?
\\
#+BEGIN_SRC haskell
Parser a :: String -> [(a, String)]
#+END_SRC
"A parser for things is a function from strings to lists of pairs of things and strings."

-- [[http://www.willamette.edu/~fruehr/haskell/seuss.html][Dr Seuss on parsers]]\\
\\
\\
Or in our case something like:
#+BEGIN_SRC c++
template <typename T>
using parser = auto (*)(string) -> list<pair<T, string>>;
#+END_SRC

** Parsers

#+BEGIN_SRC c++
template <typename T>
using parser = auto (*)(string) -> list<pair<T, string>>;
#+END_SRC

Of course, we don't really mean quite this...

#+ATTR_REVEAL: :frag (appear)
 - ~string~ -> ~string_view~ (or compile-time stringlike thing)
 - ~list~ -> ~optional~ (simpler)
 - "function" -> "something invocable"

#+BEGIN_NOTES
Strings are any stringlike thing - ~string_view~ will do nicely since we're just
reading this from a literal. The input is obvious, the output is the leftover
part of the string after parsing a T.

List represents optionality - a given string might have several ways it can be
parsed. For simplicity we can just assume one way or error, i.e. optional.

Of course we'll use the ~constexpr~ friendly ~pair~.

And when we say "function" we mean the usual invocable things. Including ~constexpr~
lambdas!
#+END_NOTES

* The Future
** The destructor problem

Currently any type with a non-trivial destructor cannot be used in ~constexpr~ context.

trivially destructible quiz time!

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
};

static_assert(std::is_trivially_destructible<S>);
#+END_SRC

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
  int i;
};

static_assert(std::is_trivially_destructible<S>);
#+END_SRC

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
  std::unique_ptr<int> i;
};

static_assert(std::is_trivially_destructible<S>);
#+END_SRC

** ~is_trivially_destructible~

Does this ~static_assert~ succeed?

#+BEGIN_SRC c++
struct S {
  ~S() {}
};

static_assert(std::is_trivially_destructible<S>);
#+END_SRC

** Why is this a problem?

It's easy to build a ~constexpr~ enabled type that can grow at runtime or fail to
compile if it gets too big in ~constexpr~ context.

#+BEGIN_SRC c++
struct Container {
  std::array<int, 10> data{};
  std::size_t length = 0;
  int *extra_data = nullptr;
  void push_back(const int i) {
    if (length >= data.size()) {
      if (!extra_data) {
        extra_data = new int[100];
      }
      extra_data[(length++) - data.size()] = i;
    } else {
      data[length++] = i;
    }
  }
};
#+END_SRC

** Why is this a problem?

But as soon as we add a destructor, the class is no longer usable in a ~constexpr~ context.

So we can build this type, but we are required to leak memory if it grows beyond the static size!

** Solutions to the ~constexpr~ destructor problem

#+BEGIN_SRC c++
struct Container {
  ~Container() {
    // this proposal allows for an empty constructor to be allowed
    if constexpr(something) {
      // do something
    }
  }
};
#+END_SRC

** Solutions to the ~constexpr~ destructor problem

#+BEGIN_SRC c++
struct Container {
  ~Container() {
    // but why not treat it like any other constexpr code?
    // allow it as long as only constexpr allowed actions
    // happen at compile time?
    if (extra_data) {
      delete [] extra_data;
    }
  }
};
#+END_SRC

** The debugging problem

On which line does GCC report an error?

#+BEGIN_SRC c++
constexpr int do_something()
{
  int val[1]{};
  return val[1];
}

int main()
{
  constexpr auto val = do_something();
}
#+END_SRC

** The debugging problem

Several times during debugging we had to take the code from compile time context 
to runtime context to allow for actual debugging.

** The debugging problem

This proposal adds debugging capability at compile time.

[[./constexpr_trace.png]]

** ~constexpr_vector~

This other proposal from the same author allows for a special type of ~constexpr_vector~
that is allowed to grow and shrink at compile time only, requiring compiler support.

[[./constexpr_vector.png]]

* The Cost
** Cognitive Cost

#+ATTR_REVEAL: :frag (appear)
 - Flat data structures are easy to reason about
 - ~constexpr~ code forces you to consider what your code is doing and the lifetime of objects (in a good way).
 - Tree like data structures are difficult to reason about
 - Selecting data structure sizes can be difficult

** Compile-time Cost - Debug Build

#+ATTR_REVEAL: :frag (appear)
 - 6GB RAM!
 - >2 Minutes Build Time
 - 338K Binary
 - Tweaking debug level can have a great affect. This might be related to symbol sizes

** Compile-time Cost - Release Build

#+ATTR_REVEAL: :frag (appear)
 - 328MB RAM!
 - 5s Build Time
 - 9K Binary


* End
