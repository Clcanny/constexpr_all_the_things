#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: toc:nil <:nil timestamp:nil email:t reveal_slide_number:"c/t"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: blood
#+REVEAL_HLEVEL: 1
#+REVEAL_EXTRA_CSS: ./presentation.css
#+REVEAL_ROOT: ./reveal.js/

#+TITLE: constexpr ALL the things!
#+AUTHOR: Ben Deane & Jason Turner
#+EMAIL: bdeane@blizzard.com, jason@emptycrate.com
#+DATE: May 16th, 2017

#+REVEAL_HTML: <script type="text/javascript" src="./presentation.js"></script>

* Title slide settings                                             :noexport:
#+BEGIN_SRC emacs-lisp
(setq org-reveal-title-slide
(concat "<img src=\"title.png\">"
"<h3>Ben Deane / <a href=\"mailto:bdeane@blizzard.com\">bdeane@blizzard.com</a> / "
"<a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3>"
"<h3>Jason Turner / <a href=\"mailto:jason@emptycrate.com\">jason@emptycrate.com</a> / "
"<a href=\"http://twitter.com/lefticus\">@lefticus</a></h3>"
"<h4>C++Now / Tuesday 16th May 2017</h4>"))
#+END_SRC

* Don't Bury The Lede

We want to do this:

#+BEGIN_SRC c++
constexpr auto jsv
  = R"({
        "feature-x-enabled": true,
        "value-of-y": 1729,
        "z-options": {"a": null,
                      "b": "joshua",
                      "c": [6, 28, 496]}
       })"_json;
if constexpr (jsv["feature-x-enabled"]) {
  // code for feature x
} else {
  // code when feature x turned off
}
#+END_SRC

#+BEGIN_NOTES
When I first heard about ~constexpr~ I immediately thought of the potential for
this: generating compile-time data structures with UDLs. And JSON is an obvious
choice for a proof-of-concept.
#+END_NOTES

* The Promise of ~constexpr~
 - Runtime efficiency
 - Clearer code, fewer magic numbers
 - Less cross-platform pain

#+BEGIN_NOTES
Doing work at compile-time instead of runtime. Obvious gain.

Simplifying code through compile-time computation. No need for manual math,
preprocessor computation "to be sure", magic numbers.

Reducing steps in the toolchain. Don't maintain generation scripts: put it in
the C++.
#+END_NOTES

*  ~constexpr~ History 101
A Short, Incomplete (and Mostly Wrong?) History of ~constexpr~

** ~constexpr~: The First Age
#+ATTR_REVEAL: :frag (appear)
 - One expression per function was allowed
 - ~constexpr~ math functions explored
 - ~throw~ link error trick discovered
 - Recursive ~constexpr~ FNV1 string hash discovered

#+BEGIN_NOTES
C++11 constexpr was "extreme recursion" but many things were doable nonetheless.

Scott Schurr's talks at CppNow/CppCon hinted at things to come and expounded on
the throw trick for forcing compile-time evaluation.
#+END_NOTES

** ~constexpr~: End of the First Age
#+BEGIN_SRC c++
// 1. Fall of Gondolin
// 2. Balrogs destroyed
// 3. Morgoth defeated and cast into the Timeless Void
// 4. constexpr string hashing discovered

constexpr uint64_t fnv1(uint64_t h, const char* s)
{
  return (*s == 0) ? h :
    fnv1((h * 1099511628211ull) ^ static_cast<uint64_t>(*s), s+1);
}
#+END_SRC

#+BEGIN_NOTES
At this point most people are probably familiar with this or something like it.
#+END_NOTES

** ~constexpr~: The Second Age
#+ATTR_REVEAL: :frag (appear)
 - Generalized ~constexpr~ supported by Visual C++
 - Compile-time computation/optimization popularized by [[https://www.youtube.com/playlist?list=PLs3KjaCtOwSZ2tbuV1hx8Xz-rFZTan2J1][/C++ Weekly/]] et al.
 - Generalized ~constexpr~ string hashing (e.g. Murmur3) discovered
 - ~constexpr~ libraries start to appear

#+BEGIN_NOTES
For some reason, the major application of ~constexpr~ reported in the mainstream
seems to be string hashing.
#+END_NOTES

** ~constexpr~: End of the Second Age
[[./cpp14_murmur.png]]

(Also: Last Alliance of Elves & Men, Isildur takes up the hilt of Narsil and
cuts the One Ring from Sauron's hand.)

** ~constexpr~: The Third Age?
#+ATTR_REVEAL: :frag (appear)
 - ~constexpr~ lambdas
 - ~if constexpr~
 - ~constexpr~ STL proliferation?
 - (coming soon, no doubt) ~constexpr~ cryptographic hashes

#+BEGIN_NOTES
~constexpr~ lambdas are a really powerful thing (as we shall see).

~if constexpr~ replaces many ~std::enable_if~ uses, more.

A selection of interesting ~constexpr~ things in the STL: ~string_view~,
~array~, almost all of ~chrono~.

New STL features are born with ~constexpr~ (somewhat) in mind: ~optional~,
~variant~.
#+END_NOTES

* Building Data Structures

** Requirements for compile-time types

** STL shortcomings
 - ~array~
 - ~string~
 - ~string_view~
 - ~pair~
 - ~optional~
 - ~variant~

* Algorithms

** Let's make them all ~constexpr~ already
[[./bryce_tweet.png]]

* Literals

** Parsing
#+REVEAL_HTML: <br>

#+BEGIN_SRC haskell
Parser a :: String -> [(a, String)]
#+END_SRC
"A parser for things is a function from strings to lists of pairs of things and strings."

-- [[http://www.willamette.edu/~fruehr/haskell/seuss.html][Dr Seuss on parsers]]

#+REVEAL_HTML: <br><br>

Or in our case something like:
#+BEGIN_SRC c++
template <typename T>
using parser = auto (*)(string) -> list<pair<T, string>>;
#+END_SRC
